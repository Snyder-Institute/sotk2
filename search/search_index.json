{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"index.html","text":"Spatial Omics Toolkit 2 (sotk2) Last updated: December 27, 2025 What is sotk2 sotk2 is an R package for integrating omics datasets using modules derived from non-negative matrix factorization (NMF) or consensus NMF (cNMF). The core idea is to treat each gene expression program (metagene) as a comparable unit across datasets, then integrate programs through a correlation-based network followed by community detection. sotk2 is designed to be self-contained and independent: it does not require any prior packages or objects outside this repository. Inputs may come from any platform or modality (for example, bulk RNA-seq, single-cell RNA-seq, spatial transcriptomics, or protein abundance), as long as NMF/cNMF outputs are available (or can be imported). Features Identification of biologically meaningful latent factors from deconvoluted omics data Data-driven rank selection across multiple NMF or cNMF runs Correlation-based integration of biological modules across datasets and platforms Support for spatial, bulk, single-cell, and protein-level omics data Community abstraction and network-level visualization for large integrative analyses Assessing sample-type enrichment using Pearson residuals (observed vs expected counts; Chi-squared framework) Consistent network layouts for comparative, cross-dataset interpretation Concepts sotk2 organizes analysis into two primary objects: SpatialOmicsSet Stores per-dataset NMF results (as NMF.rank objects) Concatenates basis (W) matrices across ranks/datasets Computes the metagene\u2013metagene correlation matrix MetageneCorrelationNetwork Thresholds correlations and builds a metagene graph Detects communities and stores community membership Computes layouts for plotting and creates an optional community-level aggregated network Key differences between SOTK and sotk2 sotk2 extends the original SOTK workflow from \u201crank selection within a dataset\u201d to cross-dataset, cross-platform module integration . The emphasis shifts from choosing an optimal k in a single analysis to building a comparable module space across datasets and extracting communities that persist across ranks and cohorts. Feature sotk2 SOTK Primary goal Cross-dataset and cross-modality integration using deconvolution-derived modules Data-driven selection of an optimal latent factor number within a dataset Input data types Any modality with NMF/cNMF outputs (bulk, single-cell, spatial transcriptomics, protein abundance) Spatial transcriptomics\u2013focused Integration scope Across datasets, cohorts, platforms, and modalities via correlation networks Within dataset (single platform) Network representation Metagene-level networks plus community-level abstraction to scale integration and interpretation Metagene-level networks Composition assessment Residual-based overrepresentation to summarize sample-type composition at the community level Limited or dataset-specific Comparative visualization Consistent-layout community networks to support direct cross-dataset comparison Basic plotting Gene interpretation Built-in extraction of metagene-associated genes (MAGs) and selection of contributing community genes for annotation Metagene genes (limited) Intended outcome Identify robust communities/modules and compare their presence and composition across datasets Choose k and interpret metagenes Citation If you use sotk2 in your work, please cite the associated manuscript: to be added","title":"Home"},{"location":"index.html#spatial-omics-toolkit-2-sotk2","text":"Last updated: December 27, 2025","title":"Spatial Omics Toolkit 2 (sotk2)"},{"location":"index.html#what-is-sotk2","text":"sotk2 is an R package for integrating omics datasets using modules derived from non-negative matrix factorization (NMF) or consensus NMF (cNMF). The core idea is to treat each gene expression program (metagene) as a comparable unit across datasets, then integrate programs through a correlation-based network followed by community detection. sotk2 is designed to be self-contained and independent: it does not require any prior packages or objects outside this repository. Inputs may come from any platform or modality (for example, bulk RNA-seq, single-cell RNA-seq, spatial transcriptomics, or protein abundance), as long as NMF/cNMF outputs are available (or can be imported).","title":"What is sotk2"},{"location":"index.html#features","text":"Identification of biologically meaningful latent factors from deconvoluted omics data Data-driven rank selection across multiple NMF or cNMF runs Correlation-based integration of biological modules across datasets and platforms Support for spatial, bulk, single-cell, and protein-level omics data Community abstraction and network-level visualization for large integrative analyses Assessing sample-type enrichment using Pearson residuals (observed vs expected counts; Chi-squared framework) Consistent network layouts for comparative, cross-dataset interpretation","title":"Features"},{"location":"index.html#concepts","text":"sotk2 organizes analysis into two primary objects: SpatialOmicsSet Stores per-dataset NMF results (as NMF.rank objects) Concatenates basis (W) matrices across ranks/datasets Computes the metagene\u2013metagene correlation matrix MetageneCorrelationNetwork Thresholds correlations and builds a metagene graph Detects communities and stores community membership Computes layouts for plotting and creates an optional community-level aggregated network","title":"Concepts"},{"location":"index.html#key-differences-between-sotk-and-sotk2","text":"sotk2 extends the original SOTK workflow from \u201crank selection within a dataset\u201d to cross-dataset, cross-platform module integration . The emphasis shifts from choosing an optimal k in a single analysis to building a comparable module space across datasets and extracting communities that persist across ranks and cohorts. Feature sotk2 SOTK Primary goal Cross-dataset and cross-modality integration using deconvolution-derived modules Data-driven selection of an optimal latent factor number within a dataset Input data types Any modality with NMF/cNMF outputs (bulk, single-cell, spatial transcriptomics, protein abundance) Spatial transcriptomics\u2013focused Integration scope Across datasets, cohorts, platforms, and modalities via correlation networks Within dataset (single platform) Network representation Metagene-level networks plus community-level abstraction to scale integration and interpretation Metagene-level networks Composition assessment Residual-based overrepresentation to summarize sample-type composition at the community level Limited or dataset-specific Comparative visualization Consistent-layout community networks to support direct cross-dataset comparison Basic plotting Gene interpretation Built-in extraction of metagene-associated genes (MAGs) and selection of contributing community genes for annotation Metagene genes (limited) Intended outcome Identify robust communities/modules and compare their presence and composition across datasets Choose k and interpret metagenes","title":"Key differences between SOTK and sotk2"},{"location":"index.html#citation","text":"If you use sotk2 in your work, please cite the associated manuscript: to be added","title":"Citation"},{"location":"annotations.html","text":"Introduction The workflows presented here annotate the community-level network using existing sample annotations. When users have expression profiles without accompanying labels, the resulting network annotations can still provide an interpretive framework by supporting inference based on established molecular markers (for example, Verhaak subtype signatures), clinical context (for example, primary versus recurrence status), and anatomical features (for example, tumor core versus edge), leveraging communities that have already been annotated in reference cohorts. The scripts in this section are not intended to be fully generalizable, because sample identifiers and available annotations can differ substantially across cohorts. For example, in the GLASS cohort, sample identifiers are de-identified barcodes and must be linked to external metadata to enable annotation. In contrast, the IVYGAP dataset encodes anatomical context directly in sample names, such that certain anatomical features may be inferred without an additional metadata table. Accordingly, the scripts below are cohort-specific and should be adapted as needed for other datasets and naming conventions. Directory settings This block defines the working directory used throughout the demo to store downloaded inputs and generated outputs. # If you want to use a user-defined output directory, # uncomment and set the download_dir parameter. # download_dir <- \"/path/to/download\" # where soObj.RDS is located if (exists(\"download_dir\") && is.character(download_dir) && length(download_dir) == 1 && nzchar(download_dir)) { download_dir <- download_dir } else { download_dir <- tools::R_user_dir(\"sotk2\", \"data\") } if (!dir.exists(download_dir)) { dir.create(download_dir, recursive = TRUE) message(download_dir, \" created.\") } Load the spatial omics object We load the previously generated soObj object, which contains the correlation network and community detection results produced in the earlier steps of the workflow. The script first attaches the sotk2 package and then checks whether soObj.RDS is present in download_dir . library(sotk2) if (file.exists(file.path(download_dir, \"soObj.RDS\"))) { soObj <- readRDS(file.path(download_dir, \"soObj.RDS\")) } else { stop(\"ERROR: the soObj.RDS file not found.\") } Annotation colors This section defines a cohort-specific color map used to standardize visual annotations across figures. The object pieColors specifies A named color palette for IVYGAP anatomical features Nested palettes for GLASS sample-level metadata, including sampleType (for example, Primary versus Recurrence) and molecularSubtype (for example, Classical, Mesenchymal, and Proneural). pieColors <- list( IVYGAP = c( \"CT\" = \"red\", # cellular tumor \"IT\" = \"orange\", # infiltrating tumor \"LE\" = \"gold\", # tumor\u2019s leading edge \"MVP\" = \"darkslategray4\", # microvascular proliferations \"PAN\" = \"burlywood4\" # palisading cells around necrosis ), GLASS = list( \"sampleType\" = c( \"Primary\" = \"chartreuse1\", \"Recurrence\" = \"darkgreen\" ), \"molecularSubtype\" = c( \"Classical\" = \"deepskyblue2\", \"Mesenchymal\" = \"deeppink3\", \"Proneural\" = \"coral3\" ) ) ) User-defined functions This section defines helper functions that translate cohort-specific sample identifiers into index sets used for downstream annotation and visualization. Because naming conventions and available metadata differ by cohort, these utilities provide a reproducible way to map samples to biologically meaningful groups. .getIVYGAPidx() parses IVYGAP sample identifiers to extract abbreviated anatomical region labels (for example, CT, IT, LE, MVP, PAN) based on the encoded naming pattern, and returns indices for each region class. .getGLASSidx() maps GLASS sample identifiers to phenotype categories using an external metadata table ( db ), returning indices for sample type (Primary versus Recurrence) and molecular subtype (Classical, Mesenchymal, Proneural). geoMean() computes the geometric mean and can be used to summarize metagene usage (or other positive-valued quantities) at the sample, community, or cohort level. This summary is often useful for comparing relative activity across communities while reducing sensitivity to extreme values. .getIVYGAPidx <- function(x) { ctIdx <- c(); itIdx <- c(); leIdx <- c(); mvpIdx <- c(); panIdx <- c() if (!is.null(x)) { region <- stringr::str_sub( sapply(stringr::str_split(x, \"__\"), \"[[\", 2), 0, 3 ) ctIdx <- which(region == \"Cel\") itIdx <- which(region == \"Inf\") leIdx <- which(region == \"Lea\") mvpIdx <- which(region == \"Mic\") panIdx <- which(region == \"Pse\") } return(list(CT = ctIdx, IT = itIdx, LE = leIdx, MVP = mvpIdx, PAN = panIdx)) } .getGLASSidx <- function(x, db) { priIdx <- c(); recIdx <- c() claIdx <- c(); mesIdx <- c(); proIdx <- c() if (!is.null(x)) { sub <- db[which(rownames(db) %in% x), c(\"sample_type\", \"Subtype\")] priIdx <- which(sub$sample_type == \"Primary\") recIdx <- which(sub$sample_type == \"Recurrence\") claIdx <- which(sub$Subtype == \"Classical\") mesIdx <- which(sub$Subtype == \"Mesenchymal\") proIdx <- which(sub$Subtype == \"Proneural\") } return(list( \"sampleType\" = list(Pri = priIdx, Rec = recIdx), \"molecularSubtype\" = list(Cla = claIdx, Mes = mesIdx, Pro = proIdx) )) } geoMean <- function(x) exp(mean(log(x))) Community annotation This section annotates the community-level network using GLASS sample metadata and renders a community-level visualization in which each community node is summarized by the distribution of sample types (Primary versus Recurrence) and molecular subtypes (Classical, Mesenchymal, Proneural). The pie encodes standardized residuals from a chi-squared test, defined as residual = (observed - expected) / sqrt(expected) . Larger positive residuals indicate an over-representation of the category relative to the null expectation, whereas larger negative residuals indicate an under-representation. The magnitude of the residual reflects the strength of deviation from independence, with values further from zero providing stronger evidence that the observed frequency differs meaningfully from the expected frequency under the Chi-squared model. [GLASS] Primary vs. Recurrence Briefly, the code (i) extracts metagene-to-community assignments from the correlation network, (ii) loads the GLASS annotation table ( annot_GLASS.RDS ), and (iii) aggregates, for each community, the set of samples associated with its constituent GEPs (via the GLASS metagene-to-sample mapping). The helper function .getGLASSidx() is then used to map those samples to metadata-defined groups, and the resulting counts are stored as a per-community \"pie\" vector. Communities with non-zero counts are displayed with appropriately scaled node sizes and labels. corNetwork <- soObj@corNetwork clusterMembership <- soObj@sample2metagene community <- c(1:length(soObj@commCols)) commNetwork <- soObj@commNetwork allGEPs <- data.frame( Data = sapply(stringr::str_split(igraph::V(corNetwork)$name, \"\\\\$\"), \"[[\", 1), GEP = igraph::V(corNetwork)$name, Community = igraph::V(corNetwork)$community ) if (file.exists(file.path(download_dir, \"annot_GLASS.RDS\"))) { glassAnnot <- readRDS(file.path(download_dir, \"annot_GLASS.RDS\")) message(\"annot_GLASS.RDS file imported.\") } else { stop(\"Please download annot_GLASS.RDS by running 03_download.R.\") } ## annot_GLASS.RDS file imported. dName <- \"GLASS\" legend <- names(pieColors[[dName]][[\"sampleType\"]]) legendCol <- pieColors[[dName]][[\"sampleType\"]] cl <- clusterMembership[[dName]] subGEPs <- allGEPs[which(allGEPs$Data == dName),] # init vertexLabel <- rep(\"\", length(community)); names(vertexLabel) <- community vertexSize <- rep(0.1, length(community)); names(vertexSize) <- community vertexPie <- rep_len(list(numeric(length(legend))), length(community)) names(vertexPie) <- paste0(\"Community_\", community) for (whichComm in community) { message(whichComm) commName <- paste0(\"Community_\", whichComm) commSpecificGEPs <- subGEPs[which(subGEPs$Community == whichComm),] if (nrow(commSpecificGEPs) > 0) { allSamples <- c() for (gep in commSpecificGEPs$GEP) { allSamples <- c(allSamples, cl[[gep]]) } noSamples <- .getGLASSidx(unique(allSamples), glassAnnot) noSamples <- sapply(noSamples[[\"sampleType\"]], length) if (sum(noSamples) != 0) { vertexPie[[commName]] <- noSamples vertexSize[whichComm] <- igraph::V(commNetwork)$size[whichComm] vertexLabel[whichComm] <- igraph::V(commNetwork)$name[whichComm] } } } vertexInfo <- list( vertexLabel = vertexLabel, vertexSize = vertexSize, vertexPie = vertexPie, legend = legend, legendCol = legendCol ) plotCommNetwork(soObj, vertexInfo = vertexInfo, filename = NULL) [GLASS] Molecular subtypes legend <- names(pieColors[[dName]][[\"molecularSubtype\"]]) # Verhaak legendCol <- pieColors[[dName]][[\"molecularSubtype\"]] # init vertexLabel <- rep(\"\", length(community)); names(vertexLabel) <- community vertexSize <- rep(0.1, length(community)); names(vertexSize) <- community vertexPie <- rep_len(list(numeric(length(legend))), length(community)); names(vertexPie) <- paste0(\"Community_\", community) for (whichComm in community) { commName <- paste0(\"Community_\", whichComm) commSpecificGEPs <- subGEPs[which(subGEPs$Community == whichComm),] if (nrow(commSpecificGEPs) > 0) { allSamples <- c() for (gep in commSpecificGEPs$GEP) { allSamples <- c(allSamples, cl[[gep]]) } noSamples <- .getGLASSidx(unique(allSamples), glassAnnot) noSamples <- sapply(noSamples[[\"molecularSubtype\"]], length) if (sum(noSamples) != 0) { vertexPie[[commName]] <- noSamples vertexSize[whichComm] <- igraph::V(commNetwork)$size[whichComm] vertexLabel[whichComm] <- igraph::V(commNetwork)$name[whichComm] } } } vertexInfo <- list(vertexLabel = vertexLabel, vertexSize = vertexSize, vertexPie = vertexPie, legend = legend, legendCol = legendCol) plotCommNetwork(soObj, vertexInfo = vertexInfo, filename = NULL) [IVYGAP] Anatomical features This section annotates the community-level network using IVYGAP anatomical context derived directly from sample identifiers and generates a community-level plot summarizing the anatomical composition of each community. For each community, the script aggregates the set of samples associated with its constituent GEPs (via the IVYGAP metagene-to-sample mapping) and then applies .getIVYGAPidx() to parse sample names into anatomical region categories. The resulting category counts are stored as a per-community \"pie\" vector and used to render pie-chart node annotations, with node size and labels inherited from the community network. dName <- \"IVYGAP\" legend <- c(\"Cellular_Tumor\", \"Infiltrating_Tumor\", \"Leading_Edge\", \"Microvascular_proliferation\", \"Pseudopalisading_cells_around_necrosis\") legendLbl <- names(pieColors[[dName]]) legendCol <- pieColors[[dName]] cl <- clusterMembership[[dName]] subGEPs <- allGEPs[which(allGEPs$Data == dName),] # init vertexLabel <- rep(\"\", length(community)); names(vertexLabel) <- community vertexSize <- rep(0.1, length(community)); names(vertexSize) <- community vertexPie <- rep_len(list(numeric(length(legend))), length(community)); names(vertexPie) <- paste0(\"Community_\", community) for (whichComm in community) { commName <- paste0(\"Community_\", whichComm) commSpecificGEPs <- subGEPs[which(subGEPs$Community == whichComm),] if (nrow(commSpecificGEPs) > 0) { allSamples <- c() for (gep in commSpecificGEPs$GEP) { allSamples <- c(allSamples, cl[[gep]]) } noSamples <- .getIVYGAPidx(unique(allSamples)) noSamples <- sapply(noSamples, length) if (sum(noSamples) != 0) { vertexPie[[commName]] <- noSamples vertexSize[whichComm] <- igraph::V(commNetwork)$size[whichComm] vertexLabel[whichComm] <- igraph::V(commNetwork)$name[whichComm] } } } vertexInfo <- list(vertexLabel = vertexLabel, vertexSize = vertexSize, vertexPie = vertexPie, legend = legend, legendLbl = legendLbl, legendCol = legendCol) plotCommNetwork(soObj, vertexInfo = vertexInfo, filename = NULL) Community-level NMF usages This section quantifies and visualizes community-level activity by summarizing metagene usage patterns derived from the cNMF results. For each cohort (GLASS and IVYGAP), the script iterates over inferred communities and performs the following steps: Identifies the set of metagenes assigned to the current community and restricts them to the cohort of interest Extracts the corresponding NMF usage profiles (H/coef matrix) from the fitted NMF object Normalizes metagene usage across samples to obtain a comparable, compositional usage profile Aggregates usage across all community member metagenes by computing the geometric mean per sample. The resulting per-sample activity estimates are then stratified by cohort-specific annotations (for example, sample type and molecular subtype in GLASS; anatomical regions in IVYGAP) and visualized using empirical cumulative distribution functions (ECDFs). Users can compute the geometric mean of metagene usage (from the NMF results) to identify communities with stronger or weaker activity and to reduce the risk of misinterpretation. The ECDF plots provide a compact comparison of community activity distributions across annotation groups: They address questions such as how Community #1 and #6 differ when both appear Primary-associated based on Chi-squared residual patterns. In particular, summarizing community activity using the geometric mean of metagene usage reveals that Primary samples exhibit higher usage in Community #1, whereas Recurrence samples exhibit higher usage in Community $6. This divergence indicates that Community 1 is more plausibly interpreted as a Primary-enriched module, while Community 6 may reflect a recurrence-associated or mixed activity pattern despite similar residual-based enrichment profiles. GLASS glass <- readRDS(file.path(download_dir, \"nmfRes_GLASS.RDS\")) ivygap <- readRDS(file.path(download_dir, \"nmfRes_IVYGAP.RDS\")) dataL <- list(GLASS = glass, IVYGAP = ivygap) dName <- \"GLASS\" nmfObj <- dataL[[dName]] nodes <- igraph::V(soObj@corNetwork) community <- nodes$community names(community) <- nodes$name for (comm in c(1:length(soObj@commCols))) { metagenes <- names(community)[which(community == comm)] metagenes <- metagenes[which( sapply(stringr::str_split(metagenes, \"\\\\$\"), \"[[\", 1) == dName)] if (length(metagenes) > 0) { usageMat <- c() for (metagene in metagenes) { buff <- unlist(stringr::str_split(metagene, \"\\\\$\")) k <- as.numeric(buff[3]) rank <- as.numeric(buff[2]) usage <- NMF::coef(get(as.character(k), nmfObj$fit)) rowSum <- apply(usage, 1, sum) nUsage <- usage/rowSum usageMat <- rbind(usageMat, nUsage[rank,]) } usageMat[usageMat == 0] <- 1E-08 rep <- apply(usageMat, 2, geoMean) names(rep) <- colnames(usageMat) idx <- .getGLASSidx(names(rep), glassAnnot) priIdx <- idx[[\"sampleType\"]][[\"Pri\"]] recIdx <- idx[[\"sampleType\"]][[\"Rec\"]] claIdx <- idx[[\"molecularSubtype\"]][[\"Cla\"]] mesIdx <- idx[[\"molecularSubtype\"]][[\"Mes\"]] proIdx <- idx[[\"molecularSubtype\"]][[\"Pro\"]] pri <- rep[priIdx]; pri <- pri[order(pri)]; priF <- ecdf(rep[priIdx]) rec <- rep[recIdx]; rec <- rec[order(rec)]; recF <- ecdf(rep[recIdx]) cla <- rep[claIdx]; cla <- cla[order(cla)]; claF <- ecdf(rep[claIdx]) mes <- rep[mesIdx]; mes <- mes[order(mes)]; mesF <- ecdf(rep[mesIdx]) pro <- rep[proIdx]; pro <- pro[order(pro)]; proF <- ecdf(rep[proIdx]) plot(pri, priF(pri), col=\"chartreuse1\", xlab=\"GeoMean(GEPs)\", ylab=\"ECDF\", main=paste0(\"Community #\", comm), type=\"l\", lwd=3, xlim=c(0, max(rep)), ylim=c(0, 1) ) lines(rec, recF(rec), col=\"darkgreen\", lwd=3) lines(cla, claF(cla), col=\"deepskyblue2\", lwd=3, lty=2) lines(mes, mesF(mes), col=\"deeppink3\", lwd=3, lty=2) lines(pro, proF(pro), col=\"coral3\", lwd=3, lty=2) legend(\"bottomright\", legend=c( paste0(\"Pri (\", length(priIdx), \")\"), paste0(\"Rec (\", length(recIdx), \")\"), NA, paste0(\"Classical (\", length(claIdx), \")\"), paste0(\"Mesenchymal (\", length(mesIdx), \")\"), paste0(\"Proneural (\", length(proIdx), \")\") ), col = c(\"chartreuse1\", \"darkgreen\", NA, \"deepskyblue2\", \"deeppink3\", \"coral3\" ), pch = 15, pt.cex = 2.8, bty=\"n\", ncol=2 ) } else { message(paste0(\"No metagenes in Community #\", comm)) } } IVYGAP dName <- \"IVYGAP\" nmfObj <- dataL[[dName]] nodes <- igraph::V(soObj@corNetwork) community <- nodes$community names(community) <- nodes$name for (comm in c(1:length(soObj@commCols))) { metagenes <- names(community)[which(community == comm)] metagenes <- metagenes[which( sapply(stringr::str_split(metagenes, \"\\\\$\"), \"[[\", 1) == dName)] if (length(metagenes) > 0) { usageMat <- c() for (metagene in metagenes) { buff <- unlist(stringr::str_split(metagene, \"\\\\$\")) k <- as.numeric(buff[3]) rank <- as.numeric(buff[2]) usage <- NMF::coef(get(as.character(k), nmfObj$fit)) rowSum <- apply(usage, 1, sum) nUsage <- usage/rowSum usageMat <- rbind(usageMat, nUsage[rank,]) } usageMat[usageMat == 0] <- 1E-08 rep <- apply(usageMat, 2, geoMean) names(rep) <- colnames(usageMat) idx <- .getIVYGAPidx(names(rep)) ctIdx <- idx[[\"CT\"]] itIdx <- idx[[\"IT\"]] leIdx <- idx[[\"LE\"]] mvpIdx <- idx[[\"MVP\"]] panIdx <- idx[[\"PAN\"]] ct <- rep[ctIdx]; ct <- ct[order(ct)]; ctF <- ecdf(rep[ctIdx]) it <- rep[itIdx]; it <- it[order(it)]; itF <- ecdf(rep[itIdx]) le <- rep[leIdx]; le <- le[order(le)]; leF <- ecdf(rep[leIdx]) mvp <- rep[mvpIdx]; mvp <- mvp[order(mvp)]; mvpF <- ecdf(rep[mvpIdx]) pan <- rep[panIdx]; pan <- pan[order(pan)]; panF <- ecdf(rep[panIdx]) plot(ct, ctF(ct), col=\"red\", xlab=\"GeoMean(GEPs)\", ylab=\"ECDF\", main=paste0(\"Community #\", comm), type=\"l\", lwd=3, xlim=c(0, max(rep)), ylim=c(0, 1) ) lines(it, itF(it), col=\"orange\", lwd=3) lines(le, leF(le), col=\"gold\", lwd=3) lines(mvp, mvpF(mvp), col=\"darkslategray4\", lwd=3) lines(pan, panF(pan), col=\"burlywood4\", lwd=3) legend(\"bottomright\", legend=c( paste0(\"CT (\", length(ctIdx), \")\"), paste0(\"IT (\", length(ctIdx), \")\"), paste0(\"LE (\", length(ctIdx), \")\"), paste0(\"MVP (\", length(ctIdx), \")\"), paste0(\"PAN (\", length(ctIdx), \")\") ), col = c(\"red\", \"orange\", \"gold\", \"darkslategray4\", \"burlywood4\"), pch = 15, pt.cex = 2.8, bty=\"n\", ncol=1 ) } else { message(paste0(\"No metagenes in Community #\", comm)) } } ## No metagenes in Community #4 ## No metagenes in Community #8 Community-assigned Visium spots The script below illustrates a representative visualization for a single Visium sample ( UKF269_T ) and generates a two-panel figure: Seurat SNN (shared nearest neighbor) clustering results. sotk2 community annotations, where each spot may be associated with multiple communities. This section requires the full demo dataset from Zenodo, including the Visium object ( UKF269_T_Visium.RDS ) and the spot-level community assignments ( UKF269_T_spots.RDS ). The workflow proceeds by loading and updating the Seurat object, harmonizing spot identifiers, defining color palettes for both SNN clusters and community labels, and then producing side-by-side spatial plots. Spots without community assignments are explicitly labeled as excluded (\u201cExc\u201d), and spots assigned to multiple communities are summarized by concatenating community identifiers (with multi-community assignments beyond pairwise combinations collapsed into a single label for visualization). # download_dir <- \"/path/to/download\" # where the demo .RDS files are located library(Seurat) library(stringr) library(ggplot2) library(gridExtra) if (file.exists(file.path(download_dir, \"UKF269_T_Visium.RDS\"))) { seuratObj <- readRDS(file.path(download_dir, \"UKF269_T_Visium.RDS\")) seuratObj <- Seurat::UpdateSeuratObject(seuratObj) seuratObj <- Seurat::RenameCells(seuratObj, add.cell.id = \"269_T_\") visSpots <- readRDS(file.path(download_dir, \"UKF269_T_spots.RDS\")) # Community annotations } snnCol <- c(\"#1B9E77\", \"#D95F02\", \"#7570B3\", \"#E7298A\", \"#66A61E\", \"#E6AB02\", \"#A6761D\", \"#666666\", \"#8DD3C7\", \"#FB8072\", \"#80B1D3\", \"#FDB462\", \"#B3DE69\") names(snnCol) <- c(\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\") commCol <- c(\"#A6761D\", \"#66A61E\", \"#1B9E77\", \"#E7298A\", \"magenta\", \"grey50\", \"#D95F02\", \"#7570B3\", \"#8DD3C7\", \"beige\", \"#ececec\") names(commCol) <- c(\"9-10\", \"10\", \"5-10\", \"5\", \"2-5\", \"Exc\", \"2\", \"2-10\", \"2-9\", \"2\", \"0\") SpatialDimPlot( seuratObj, group.by = \"seurat_clusters\", label = TRUE, label.size = 3, pt.size.factor = 250) + theme(legend.position = \"right\") + labs(title = \"UKF269_T, SNN\") + scale_fill_manual(values = snnCol[levels(seuratObj@meta.data$seurat_clusters)]) excluded <- c(); community <- c() for (spotName in rownames(seuratObj@meta.data)) { if (spotName %in% names(visSpots)) { comm <- paste(sort(unlist(visSpots[spotName])), collapse=\"-\") if (str_count(comm, \"-\") > 1) comm <- 0 } else { comm <- \"Exc\" excluded <- c(excluded, spotName) } community <- c(community, comm) } community <- factor(community) seuratObj@meta.data$community <- community SpatialDimPlot(seuratObj, group.by = \"community\", label = TRUE, label.size = 3, pt.size.factor = 250) + theme(legend.position = \"right\") + labs(title = \"UKF269_T, Community\") + scale_fill_manual(values = commCol[levels(community)])","title":"Annotations"},{"location":"annotations.html#introduction","text":"The workflows presented here annotate the community-level network using existing sample annotations. When users have expression profiles without accompanying labels, the resulting network annotations can still provide an interpretive framework by supporting inference based on established molecular markers (for example, Verhaak subtype signatures), clinical context (for example, primary versus recurrence status), and anatomical features (for example, tumor core versus edge), leveraging communities that have already been annotated in reference cohorts. The scripts in this section are not intended to be fully generalizable, because sample identifiers and available annotations can differ substantially across cohorts. For example, in the GLASS cohort, sample identifiers are de-identified barcodes and must be linked to external metadata to enable annotation. In contrast, the IVYGAP dataset encodes anatomical context directly in sample names, such that certain anatomical features may be inferred without an additional metadata table. Accordingly, the scripts below are cohort-specific and should be adapted as needed for other datasets and naming conventions.","title":"Introduction"},{"location":"annotations.html#directory-settings","text":"This block defines the working directory used throughout the demo to store downloaded inputs and generated outputs. # If you want to use a user-defined output directory, # uncomment and set the download_dir parameter. # download_dir <- \"/path/to/download\" # where soObj.RDS is located if (exists(\"download_dir\") && is.character(download_dir) && length(download_dir) == 1 && nzchar(download_dir)) { download_dir <- download_dir } else { download_dir <- tools::R_user_dir(\"sotk2\", \"data\") } if (!dir.exists(download_dir)) { dir.create(download_dir, recursive = TRUE) message(download_dir, \" created.\") }","title":"Directory settings"},{"location":"annotations.html#load-the-spatial-omics-object","text":"We load the previously generated soObj object, which contains the correlation network and community detection results produced in the earlier steps of the workflow. The script first attaches the sotk2 package and then checks whether soObj.RDS is present in download_dir . library(sotk2) if (file.exists(file.path(download_dir, \"soObj.RDS\"))) { soObj <- readRDS(file.path(download_dir, \"soObj.RDS\")) } else { stop(\"ERROR: the soObj.RDS file not found.\") }","title":"Load the spatial omics object"},{"location":"annotations.html#annotation-colors","text":"This section defines a cohort-specific color map used to standardize visual annotations across figures. The object pieColors specifies A named color palette for IVYGAP anatomical features Nested palettes for GLASS sample-level metadata, including sampleType (for example, Primary versus Recurrence) and molecularSubtype (for example, Classical, Mesenchymal, and Proneural). pieColors <- list( IVYGAP = c( \"CT\" = \"red\", # cellular tumor \"IT\" = \"orange\", # infiltrating tumor \"LE\" = \"gold\", # tumor\u2019s leading edge \"MVP\" = \"darkslategray4\", # microvascular proliferations \"PAN\" = \"burlywood4\" # palisading cells around necrosis ), GLASS = list( \"sampleType\" = c( \"Primary\" = \"chartreuse1\", \"Recurrence\" = \"darkgreen\" ), \"molecularSubtype\" = c( \"Classical\" = \"deepskyblue2\", \"Mesenchymal\" = \"deeppink3\", \"Proneural\" = \"coral3\" ) ) )","title":"Annotation colors"},{"location":"annotations.html#user-defined-functions","text":"This section defines helper functions that translate cohort-specific sample identifiers into index sets used for downstream annotation and visualization. Because naming conventions and available metadata differ by cohort, these utilities provide a reproducible way to map samples to biologically meaningful groups. .getIVYGAPidx() parses IVYGAP sample identifiers to extract abbreviated anatomical region labels (for example, CT, IT, LE, MVP, PAN) based on the encoded naming pattern, and returns indices for each region class. .getGLASSidx() maps GLASS sample identifiers to phenotype categories using an external metadata table ( db ), returning indices for sample type (Primary versus Recurrence) and molecular subtype (Classical, Mesenchymal, Proneural). geoMean() computes the geometric mean and can be used to summarize metagene usage (or other positive-valued quantities) at the sample, community, or cohort level. This summary is often useful for comparing relative activity across communities while reducing sensitivity to extreme values. .getIVYGAPidx <- function(x) { ctIdx <- c(); itIdx <- c(); leIdx <- c(); mvpIdx <- c(); panIdx <- c() if (!is.null(x)) { region <- stringr::str_sub( sapply(stringr::str_split(x, \"__\"), \"[[\", 2), 0, 3 ) ctIdx <- which(region == \"Cel\") itIdx <- which(region == \"Inf\") leIdx <- which(region == \"Lea\") mvpIdx <- which(region == \"Mic\") panIdx <- which(region == \"Pse\") } return(list(CT = ctIdx, IT = itIdx, LE = leIdx, MVP = mvpIdx, PAN = panIdx)) } .getGLASSidx <- function(x, db) { priIdx <- c(); recIdx <- c() claIdx <- c(); mesIdx <- c(); proIdx <- c() if (!is.null(x)) { sub <- db[which(rownames(db) %in% x), c(\"sample_type\", \"Subtype\")] priIdx <- which(sub$sample_type == \"Primary\") recIdx <- which(sub$sample_type == \"Recurrence\") claIdx <- which(sub$Subtype == \"Classical\") mesIdx <- which(sub$Subtype == \"Mesenchymal\") proIdx <- which(sub$Subtype == \"Proneural\") } return(list( \"sampleType\" = list(Pri = priIdx, Rec = recIdx), \"molecularSubtype\" = list(Cla = claIdx, Mes = mesIdx, Pro = proIdx) )) } geoMean <- function(x) exp(mean(log(x)))","title":"User-defined functions"},{"location":"annotations.html#community-annotation","text":"This section annotates the community-level network using GLASS sample metadata and renders a community-level visualization in which each community node is summarized by the distribution of sample types (Primary versus Recurrence) and molecular subtypes (Classical, Mesenchymal, Proneural). The pie encodes standardized residuals from a chi-squared test, defined as residual = (observed - expected) / sqrt(expected) . Larger positive residuals indicate an over-representation of the category relative to the null expectation, whereas larger negative residuals indicate an under-representation. The magnitude of the residual reflects the strength of deviation from independence, with values further from zero providing stronger evidence that the observed frequency differs meaningfully from the expected frequency under the Chi-squared model.","title":"Community annotation"},{"location":"annotations.html#glass-primary-vs-recurrence","text":"Briefly, the code (i) extracts metagene-to-community assignments from the correlation network, (ii) loads the GLASS annotation table ( annot_GLASS.RDS ), and (iii) aggregates, for each community, the set of samples associated with its constituent GEPs (via the GLASS metagene-to-sample mapping). The helper function .getGLASSidx() is then used to map those samples to metadata-defined groups, and the resulting counts are stored as a per-community \"pie\" vector. Communities with non-zero counts are displayed with appropriately scaled node sizes and labels. corNetwork <- soObj@corNetwork clusterMembership <- soObj@sample2metagene community <- c(1:length(soObj@commCols)) commNetwork <- soObj@commNetwork allGEPs <- data.frame( Data = sapply(stringr::str_split(igraph::V(corNetwork)$name, \"\\\\$\"), \"[[\", 1), GEP = igraph::V(corNetwork)$name, Community = igraph::V(corNetwork)$community ) if (file.exists(file.path(download_dir, \"annot_GLASS.RDS\"))) { glassAnnot <- readRDS(file.path(download_dir, \"annot_GLASS.RDS\")) message(\"annot_GLASS.RDS file imported.\") } else { stop(\"Please download annot_GLASS.RDS by running 03_download.R.\") } ## annot_GLASS.RDS file imported. dName <- \"GLASS\" legend <- names(pieColors[[dName]][[\"sampleType\"]]) legendCol <- pieColors[[dName]][[\"sampleType\"]] cl <- clusterMembership[[dName]] subGEPs <- allGEPs[which(allGEPs$Data == dName),] # init vertexLabel <- rep(\"\", length(community)); names(vertexLabel) <- community vertexSize <- rep(0.1, length(community)); names(vertexSize) <- community vertexPie <- rep_len(list(numeric(length(legend))), length(community)) names(vertexPie) <- paste0(\"Community_\", community) for (whichComm in community) { message(whichComm) commName <- paste0(\"Community_\", whichComm) commSpecificGEPs <- subGEPs[which(subGEPs$Community == whichComm),] if (nrow(commSpecificGEPs) > 0) { allSamples <- c() for (gep in commSpecificGEPs$GEP) { allSamples <- c(allSamples, cl[[gep]]) } noSamples <- .getGLASSidx(unique(allSamples), glassAnnot) noSamples <- sapply(noSamples[[\"sampleType\"]], length) if (sum(noSamples) != 0) { vertexPie[[commName]] <- noSamples vertexSize[whichComm] <- igraph::V(commNetwork)$size[whichComm] vertexLabel[whichComm] <- igraph::V(commNetwork)$name[whichComm] } } } vertexInfo <- list( vertexLabel = vertexLabel, vertexSize = vertexSize, vertexPie = vertexPie, legend = legend, legendCol = legendCol ) plotCommNetwork(soObj, vertexInfo = vertexInfo, filename = NULL)","title":"[GLASS] Primary vs. Recurrence"},{"location":"annotations.html#glass-molecular-subtypes","text":"legend <- names(pieColors[[dName]][[\"molecularSubtype\"]]) # Verhaak legendCol <- pieColors[[dName]][[\"molecularSubtype\"]] # init vertexLabel <- rep(\"\", length(community)); names(vertexLabel) <- community vertexSize <- rep(0.1, length(community)); names(vertexSize) <- community vertexPie <- rep_len(list(numeric(length(legend))), length(community)); names(vertexPie) <- paste0(\"Community_\", community) for (whichComm in community) { commName <- paste0(\"Community_\", whichComm) commSpecificGEPs <- subGEPs[which(subGEPs$Community == whichComm),] if (nrow(commSpecificGEPs) > 0) { allSamples <- c() for (gep in commSpecificGEPs$GEP) { allSamples <- c(allSamples, cl[[gep]]) } noSamples <- .getGLASSidx(unique(allSamples), glassAnnot) noSamples <- sapply(noSamples[[\"molecularSubtype\"]], length) if (sum(noSamples) != 0) { vertexPie[[commName]] <- noSamples vertexSize[whichComm] <- igraph::V(commNetwork)$size[whichComm] vertexLabel[whichComm] <- igraph::V(commNetwork)$name[whichComm] } } } vertexInfo <- list(vertexLabel = vertexLabel, vertexSize = vertexSize, vertexPie = vertexPie, legend = legend, legendCol = legendCol) plotCommNetwork(soObj, vertexInfo = vertexInfo, filename = NULL)","title":"[GLASS] Molecular subtypes"},{"location":"annotations.html#ivygap-anatomical-features","text":"This section annotates the community-level network using IVYGAP anatomical context derived directly from sample identifiers and generates a community-level plot summarizing the anatomical composition of each community. For each community, the script aggregates the set of samples associated with its constituent GEPs (via the IVYGAP metagene-to-sample mapping) and then applies .getIVYGAPidx() to parse sample names into anatomical region categories. The resulting category counts are stored as a per-community \"pie\" vector and used to render pie-chart node annotations, with node size and labels inherited from the community network. dName <- \"IVYGAP\" legend <- c(\"Cellular_Tumor\", \"Infiltrating_Tumor\", \"Leading_Edge\", \"Microvascular_proliferation\", \"Pseudopalisading_cells_around_necrosis\") legendLbl <- names(pieColors[[dName]]) legendCol <- pieColors[[dName]] cl <- clusterMembership[[dName]] subGEPs <- allGEPs[which(allGEPs$Data == dName),] # init vertexLabel <- rep(\"\", length(community)); names(vertexLabel) <- community vertexSize <- rep(0.1, length(community)); names(vertexSize) <- community vertexPie <- rep_len(list(numeric(length(legend))), length(community)); names(vertexPie) <- paste0(\"Community_\", community) for (whichComm in community) { commName <- paste0(\"Community_\", whichComm) commSpecificGEPs <- subGEPs[which(subGEPs$Community == whichComm),] if (nrow(commSpecificGEPs) > 0) { allSamples <- c() for (gep in commSpecificGEPs$GEP) { allSamples <- c(allSamples, cl[[gep]]) } noSamples <- .getIVYGAPidx(unique(allSamples)) noSamples <- sapply(noSamples, length) if (sum(noSamples) != 0) { vertexPie[[commName]] <- noSamples vertexSize[whichComm] <- igraph::V(commNetwork)$size[whichComm] vertexLabel[whichComm] <- igraph::V(commNetwork)$name[whichComm] } } } vertexInfo <- list(vertexLabel = vertexLabel, vertexSize = vertexSize, vertexPie = vertexPie, legend = legend, legendLbl = legendLbl, legendCol = legendCol) plotCommNetwork(soObj, vertexInfo = vertexInfo, filename = NULL)","title":"[IVYGAP] Anatomical features"},{"location":"annotations.html#community-level-nmf-usages","text":"This section quantifies and visualizes community-level activity by summarizing metagene usage patterns derived from the cNMF results. For each cohort (GLASS and IVYGAP), the script iterates over inferred communities and performs the following steps: Identifies the set of metagenes assigned to the current community and restricts them to the cohort of interest Extracts the corresponding NMF usage profiles (H/coef matrix) from the fitted NMF object Normalizes metagene usage across samples to obtain a comparable, compositional usage profile Aggregates usage across all community member metagenes by computing the geometric mean per sample. The resulting per-sample activity estimates are then stratified by cohort-specific annotations (for example, sample type and molecular subtype in GLASS; anatomical regions in IVYGAP) and visualized using empirical cumulative distribution functions (ECDFs). Users can compute the geometric mean of metagene usage (from the NMF results) to identify communities with stronger or weaker activity and to reduce the risk of misinterpretation. The ECDF plots provide a compact comparison of community activity distributions across annotation groups: They address questions such as how Community #1 and #6 differ when both appear Primary-associated based on Chi-squared residual patterns. In particular, summarizing community activity using the geometric mean of metagene usage reveals that Primary samples exhibit higher usage in Community #1, whereas Recurrence samples exhibit higher usage in Community $6. This divergence indicates that Community 1 is more plausibly interpreted as a Primary-enriched module, while Community 6 may reflect a recurrence-associated or mixed activity pattern despite similar residual-based enrichment profiles.","title":"Community-level NMF usages"},{"location":"annotations.html#glass","text":"glass <- readRDS(file.path(download_dir, \"nmfRes_GLASS.RDS\")) ivygap <- readRDS(file.path(download_dir, \"nmfRes_IVYGAP.RDS\")) dataL <- list(GLASS = glass, IVYGAP = ivygap) dName <- \"GLASS\" nmfObj <- dataL[[dName]] nodes <- igraph::V(soObj@corNetwork) community <- nodes$community names(community) <- nodes$name for (comm in c(1:length(soObj@commCols))) { metagenes <- names(community)[which(community == comm)] metagenes <- metagenes[which( sapply(stringr::str_split(metagenes, \"\\\\$\"), \"[[\", 1) == dName)] if (length(metagenes) > 0) { usageMat <- c() for (metagene in metagenes) { buff <- unlist(stringr::str_split(metagene, \"\\\\$\")) k <- as.numeric(buff[3]) rank <- as.numeric(buff[2]) usage <- NMF::coef(get(as.character(k), nmfObj$fit)) rowSum <- apply(usage, 1, sum) nUsage <- usage/rowSum usageMat <- rbind(usageMat, nUsage[rank,]) } usageMat[usageMat == 0] <- 1E-08 rep <- apply(usageMat, 2, geoMean) names(rep) <- colnames(usageMat) idx <- .getGLASSidx(names(rep), glassAnnot) priIdx <- idx[[\"sampleType\"]][[\"Pri\"]] recIdx <- idx[[\"sampleType\"]][[\"Rec\"]] claIdx <- idx[[\"molecularSubtype\"]][[\"Cla\"]] mesIdx <- idx[[\"molecularSubtype\"]][[\"Mes\"]] proIdx <- idx[[\"molecularSubtype\"]][[\"Pro\"]] pri <- rep[priIdx]; pri <- pri[order(pri)]; priF <- ecdf(rep[priIdx]) rec <- rep[recIdx]; rec <- rec[order(rec)]; recF <- ecdf(rep[recIdx]) cla <- rep[claIdx]; cla <- cla[order(cla)]; claF <- ecdf(rep[claIdx]) mes <- rep[mesIdx]; mes <- mes[order(mes)]; mesF <- ecdf(rep[mesIdx]) pro <- rep[proIdx]; pro <- pro[order(pro)]; proF <- ecdf(rep[proIdx]) plot(pri, priF(pri), col=\"chartreuse1\", xlab=\"GeoMean(GEPs)\", ylab=\"ECDF\", main=paste0(\"Community #\", comm), type=\"l\", lwd=3, xlim=c(0, max(rep)), ylim=c(0, 1) ) lines(rec, recF(rec), col=\"darkgreen\", lwd=3) lines(cla, claF(cla), col=\"deepskyblue2\", lwd=3, lty=2) lines(mes, mesF(mes), col=\"deeppink3\", lwd=3, lty=2) lines(pro, proF(pro), col=\"coral3\", lwd=3, lty=2) legend(\"bottomright\", legend=c( paste0(\"Pri (\", length(priIdx), \")\"), paste0(\"Rec (\", length(recIdx), \")\"), NA, paste0(\"Classical (\", length(claIdx), \")\"), paste0(\"Mesenchymal (\", length(mesIdx), \")\"), paste0(\"Proneural (\", length(proIdx), \")\") ), col = c(\"chartreuse1\", \"darkgreen\", NA, \"deepskyblue2\", \"deeppink3\", \"coral3\" ), pch = 15, pt.cex = 2.8, bty=\"n\", ncol=2 ) } else { message(paste0(\"No metagenes in Community #\", comm)) } }","title":"GLASS"},{"location":"annotations.html#ivygap","text":"dName <- \"IVYGAP\" nmfObj <- dataL[[dName]] nodes <- igraph::V(soObj@corNetwork) community <- nodes$community names(community) <- nodes$name for (comm in c(1:length(soObj@commCols))) { metagenes <- names(community)[which(community == comm)] metagenes <- metagenes[which( sapply(stringr::str_split(metagenes, \"\\\\$\"), \"[[\", 1) == dName)] if (length(metagenes) > 0) { usageMat <- c() for (metagene in metagenes) { buff <- unlist(stringr::str_split(metagene, \"\\\\$\")) k <- as.numeric(buff[3]) rank <- as.numeric(buff[2]) usage <- NMF::coef(get(as.character(k), nmfObj$fit)) rowSum <- apply(usage, 1, sum) nUsage <- usage/rowSum usageMat <- rbind(usageMat, nUsage[rank,]) } usageMat[usageMat == 0] <- 1E-08 rep <- apply(usageMat, 2, geoMean) names(rep) <- colnames(usageMat) idx <- .getIVYGAPidx(names(rep)) ctIdx <- idx[[\"CT\"]] itIdx <- idx[[\"IT\"]] leIdx <- idx[[\"LE\"]] mvpIdx <- idx[[\"MVP\"]] panIdx <- idx[[\"PAN\"]] ct <- rep[ctIdx]; ct <- ct[order(ct)]; ctF <- ecdf(rep[ctIdx]) it <- rep[itIdx]; it <- it[order(it)]; itF <- ecdf(rep[itIdx]) le <- rep[leIdx]; le <- le[order(le)]; leF <- ecdf(rep[leIdx]) mvp <- rep[mvpIdx]; mvp <- mvp[order(mvp)]; mvpF <- ecdf(rep[mvpIdx]) pan <- rep[panIdx]; pan <- pan[order(pan)]; panF <- ecdf(rep[panIdx]) plot(ct, ctF(ct), col=\"red\", xlab=\"GeoMean(GEPs)\", ylab=\"ECDF\", main=paste0(\"Community #\", comm), type=\"l\", lwd=3, xlim=c(0, max(rep)), ylim=c(0, 1) ) lines(it, itF(it), col=\"orange\", lwd=3) lines(le, leF(le), col=\"gold\", lwd=3) lines(mvp, mvpF(mvp), col=\"darkslategray4\", lwd=3) lines(pan, panF(pan), col=\"burlywood4\", lwd=3) legend(\"bottomright\", legend=c( paste0(\"CT (\", length(ctIdx), \")\"), paste0(\"IT (\", length(ctIdx), \")\"), paste0(\"LE (\", length(ctIdx), \")\"), paste0(\"MVP (\", length(ctIdx), \")\"), paste0(\"PAN (\", length(ctIdx), \")\") ), col = c(\"red\", \"orange\", \"gold\", \"darkslategray4\", \"burlywood4\"), pch = 15, pt.cex = 2.8, bty=\"n\", ncol=1 ) } else { message(paste0(\"No metagenes in Community #\", comm)) } } ## No metagenes in Community #4 ## No metagenes in Community #8","title":"IVYGAP"},{"location":"annotations.html#community-assigned-visium-spots","text":"The script below illustrates a representative visualization for a single Visium sample ( UKF269_T ) and generates a two-panel figure: Seurat SNN (shared nearest neighbor) clustering results. sotk2 community annotations, where each spot may be associated with multiple communities. This section requires the full demo dataset from Zenodo, including the Visium object ( UKF269_T_Visium.RDS ) and the spot-level community assignments ( UKF269_T_spots.RDS ). The workflow proceeds by loading and updating the Seurat object, harmonizing spot identifiers, defining color palettes for both SNN clusters and community labels, and then producing side-by-side spatial plots. Spots without community assignments are explicitly labeled as excluded (\u201cExc\u201d), and spots assigned to multiple communities are summarized by concatenating community identifiers (with multi-community assignments beyond pairwise combinations collapsed into a single label for visualization). # download_dir <- \"/path/to/download\" # where the demo .RDS files are located library(Seurat) library(stringr) library(ggplot2) library(gridExtra) if (file.exists(file.path(download_dir, \"UKF269_T_Visium.RDS\"))) { seuratObj <- readRDS(file.path(download_dir, \"UKF269_T_Visium.RDS\")) seuratObj <- Seurat::UpdateSeuratObject(seuratObj) seuratObj <- Seurat::RenameCells(seuratObj, add.cell.id = \"269_T_\") visSpots <- readRDS(file.path(download_dir, \"UKF269_T_spots.RDS\")) # Community annotations } snnCol <- c(\"#1B9E77\", \"#D95F02\", \"#7570B3\", \"#E7298A\", \"#66A61E\", \"#E6AB02\", \"#A6761D\", \"#666666\", \"#8DD3C7\", \"#FB8072\", \"#80B1D3\", \"#FDB462\", \"#B3DE69\") names(snnCol) <- c(\"0\", \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\", \"10\", \"11\", \"12\") commCol <- c(\"#A6761D\", \"#66A61E\", \"#1B9E77\", \"#E7298A\", \"magenta\", \"grey50\", \"#D95F02\", \"#7570B3\", \"#8DD3C7\", \"beige\", \"#ececec\") names(commCol) <- c(\"9-10\", \"10\", \"5-10\", \"5\", \"2-5\", \"Exc\", \"2\", \"2-10\", \"2-9\", \"2\", \"0\") SpatialDimPlot( seuratObj, group.by = \"seurat_clusters\", label = TRUE, label.size = 3, pt.size.factor = 250) + theme(legend.position = \"right\") + labs(title = \"UKF269_T, SNN\") + scale_fill_manual(values = snnCol[levels(seuratObj@meta.data$seurat_clusters)]) excluded <- c(); community <- c() for (spotName in rownames(seuratObj@meta.data)) { if (spotName %in% names(visSpots)) { comm <- paste(sort(unlist(visSpots[spotName])), collapse=\"-\") if (str_count(comm, \"-\") > 1) comm <- 0 } else { comm <- \"Exc\" excluded <- c(excluded, spotName) } community <- c(community, comm) } community <- factor(community) seuratObj@meta.data$community <- community SpatialDimPlot(seuratObj, group.by = \"community\", label = TRUE, label.size = 3, pt.size.factor = 250) + theme(legend.position = \"right\") + labs(title = \"UKF269_T, Community\") + scale_fill_manual(values = commCol[levels(community)])","title":"Community-assigned Visium spots"},{"location":"signature.html","text":"Introduction This section outlines a practical workflow for extracting metagene-associated genes (MAGs) and prioritizing highly contributing genes for each inferred community. Communities are defined on the metagene correlation network, and community-level gene importance is derived by aggregating information across the metagenes assigned to a given community. Identification of MAGs is essential for biological interpretation, because these genes provide a direct link between latent metagene structure and measurable transcriptional programs. Community-level MAG summaries can be compared against established marker sets and published gene signatures to support functional annotation, assess concordance with known biological states, and reduce the risk of over-interpreting purely network-driven community structure. Directory settings This block defines the working directory used throughout the demo to store downloaded inputs and generated outputs. # If you want to use a user-defined output directory, # uncomment and set the download_dir parameter. # download_dir <- \"/path/to/download\" if (exists(\"download_dir\") && is.character(download_dir) && length(download_dir) == 1 && nzchar(download_dir)) { download_dir <- download_dir } else { download_dir <- tools::R_user_dir(\"sotk2\", \"data\") } Load the spatial omics object We load the previously generated soObj object, which contains the correlation network and community detection results produced in the earlier steps of the workflow. The script first attaches the sotk2 package and then checks whether soObj.RDS is present in download_dir . We then import the GLASS cohort expression profile ( expr_GLASS.RDS ) downloaded from Zenodo, which is required for downstream extraction of metagene-associated genes (MAGs) and community-level gene summaries. library(sotk2) if (file.exists(file.path(download_dir, \"soObj.RDS\"))) { soObj <- readRDS(file.path(download_dir, \"soObj.RDS\")) } else { stop(\"ERROR: the soObj.RDS file not found.\") } if (file.exists(file.path(download_dir, \"expr_GLASS.RDS\"))) { expr <- readRDS(file.path(download_dir, \"expr_GLASS.RDS\")) } else { stop(\"ERROR: the soObj.RDS file not found.\") } Get metagene-associated genes This section extracts metagene-associated genes (MAGs) by integrating the GLASS expression matrix with the metagene and community structure stored in soObj . The function getMAGs() is then applied to compute, for each metagene, the set of genes most strongly associated with that metagene within the specified cohort. The resulting object ( mags ) is organized hierarchically by cohort, community, and metagene, enabling users to inspect MAGs at multiple resolutions (cohort-wide, community-level, and individual metagene-level). The final lines provide an example of accessing MAGs for a specific metagene within a given community. mags <- getMAGs(soObj, list(GLASS = expr)) message(\"MAGs for the metagenes in Community #1: \", names(mags[[\"GLASS\"]][[1]])[1]) ## MAGs for the metagenes in Community #1: GLASS$05$05 mags[[\"GLASS\"]][[1]][[1]] # [[data/cohort]][[community #]][[metagenes]] ## [1] \"ADORA3\" \"ADPRH\" \"AGTRAP\" \"AIF1\" \"AKR1A1\" \"ALDH3B1\" ## [7] \"ALOX5\" \"ALOX5AP\" \"ANXA2\" \"APOBR\" \"ARHGAP30\" \"ARHGDIB\" ## [13] \"ARPC1B\" \"ARRB2\" \"ASGR2\" \"BATF\" \"BRI3\" \"C1QA\" ## [19] \"C1QB\" \"C1QC\" \"C1R\" \"C1S\" \"C2\" \"C3AR1\" ## [25] \"CALHM2\" \"CAP1\" \"CAPG\" \"CASP1\" \"CASP4\" \"CCR1\" ## [31] \"CCRL2\" \"CD14\" \"CD300A\" \"CD300C\" \"CD300LF\" \"CD33\" ## [37] \"CD37\" \"CD4\" \"CD53\" \"CD68\" \"CD74\" \"CEBPB\" ## [43] \"CEBPD\" \"CERS2\" \"CIB1\" \"CLDN7\" \"CLIC1\" \"CNPY3\" ## [49] \"CSTB\" \"CTSA\" \"CTSB\" \"CTSC\" \"CTSD\" \"CTSL\" ## [55] \"CTSZ\" \"CXCL16\" \"CXCR4\" \"CYBA\" \"DENND1C\" \"DENND2D\" ## [61] \"DNASE2\" \"DOK1\" \"DOK2\" \"DOK3\" \"DUSP1\" \"DUSP23\" ## [67] \"EDEM2\" \"EFEMP2\" \"EMP3\" \"ENG\" \"EVA1B\" \"FAH\" ## [73] \"FBP1\" \"FCER1G\" \"FCGR2B\" \"FCGRT\" \"FERMT3\" \"FLII\" ## [79] \"FTH1\" \"FTL\" \"FUCA2\" \"GAA\" \"GNA15\" \"GPSM3\" ## [85] \"GPX1\" \"GRN\" \"GYPC\" \"HCK\" \"HCST\" \"HEXA\" ## [91] \"HLA.B\" \"HLA.DMA\" \"HLA.DPA1\" \"HLA.DPB1\" \"HLA.DRA\" \"HLA.DRB1\" ## [97] \"HLA.E\" \"HLX\" \"HSD3B7\" \"ICAM1\" \"IER3\" \"IFI30\" ## [103] \"IFNGR2\" \"IL10RB\" \"IL15RA\" \"ISG20\" \"ITGB2\" \"ITPRIP\" ## [109] \"JUN\" \"LAIR1\" \"LAPTM5\" \"LGALS1\" \"LGALS3BP\" \"LILRB3\" ## [115] \"LITAF\" \"LRRC25\" \"MAFB\" \"MGAT1\" \"MS4A4A\" \"MS4A6A\" ## [121] \"MSN\" \"MVP\" \"MXRA8\" \"MYL9\" \"MYO1G\" \"NANS\" ## [127] \"NCF2\" \"NCF4\" \"NFKBIA\" \"NPC2\" \"NUPR1\" \"OSCAR\" ## [133] \"PARVG\" \"PFN1\" \"PILRA\" \"PLAUR\" \"PLIN3\" \"PLTP\" ## [139] \"POLD4\" \"PPM1M\" \"PPP1R18\" \"PTPN6\" \"PYCARD\" \"RAB20\" ## [145] \"RAB42\" \"RAC2\" \"RASAL3\" \"RASSF1\" \"RCN3\" \"RGS19\" ## [151] \"RHOG\" \"RILPL2\" \"RIPK3\" \"RNASE6\" \"RNASET2\" \"RNF130\" ## [157] \"RRAS\" \"S100A11\" \"SASH3\" \"SERF2\" \"SERPINB1\" \"SIGLEC7\" ## [163] \"SIGLEC9\" \"SLAMF8\" \"SLC10A3\" \"SLC11A1\" \"SLC15A3\" \"SLC17A9\" ## [169] \"SLC39A1\" \"SPI1\" \"SRGN\" \"STAB1\" \"STXBP2\" \"SYNGR2\" ## [175] \"TAGLN2\" \"TAX1BP3\" \"TCIRG1\" \"TGFB1\" \"THBD\" \"THEMIS2\" ## [181] \"TLN1\" \"TMED9\" \"TMEM150A\" \"TNFRSF14\" \"TNFRSF1B\" \"TNFSF13\" ## [187] \"TNIP2\" \"TRADD\" \"TRIM21\" \"TSPO\" \"TWF2\" \"TXNDC5\" ## [193] \"TYMP\" \"TYROBP\" \"VAMP5\" \"VAMP8\" \"VAT1\" \"VKORC1\" ## [199] \"VSIG4\" \"WAS\" Get highly contributing genes This section prioritizes community-level genes by aggregating metagene-associated gene information across all metagenes assigned to each community. Using the MAGs extracted in the previous step, contributingCommunityGenes() identifies genes that contribute most strongly and consistently to a given community's metagene composition by quantifying how frequently each gene appears among the MAG sets of community member metagenes. By default, the function applies a proportion threshold of > 0.5 , meaning that a gene is retained as a highly contributing community gene only if it is identified as a MAG for more than half of the metagenes within that community. For example, if a community contains 10 metagenes, a gene must be present among the MAGs of at least 6 metagenes to be selected under the default setting. The resulting object is indexed by cohort and community, enabling direct inspection of top-ranked genes for each inferred module. The final lines print an example output showing the highly contributing genes for Community 1 in the GLASS cohort. highlyContributingCommunityGenes <- contributingCommunityGenes(soObj, mags) ## Threhold of the intersection was set to 0.5 message(\"Highly contributing genes in Community #1 from GLASS:\") ## Highly contributing genes in Community #1 from GLASS: highlyContributingCommunityGenes[[\"GLASS\"]][[1]] # Commuinty #1 ## [1] \"ALOX5AP\" \"ANXA2\" \"C1R\" \"C1S\" \"CD14\" \"CD300A\" ## [7] \"CD300C\" \"CEBPB\" \"CLIC1\" \"CSTB\" \"CTSB\" \"CTSC\" ## [13] \"CTSL\" \"CTSZ\" \"DOK2\" \"FBP1\" \"FCER1G\" \"FCGRT\" ## [19] \"GNA15\" \"HCST\" \"IER3\" \"IFI30\" \"LAPTM5\" \"LILRB3\" ## [25] \"MXRA8\" \"MYO1G\" \"NCF4\" \"NFKBIA\" \"OSCAR\" \"PLAUR\" ## [31] \"PLTP\" \"RCN3\" \"RRAS\" \"S100A11\" \"SLAMF8\" \"STAB1\" ## [37] \"TCIRG1\" \"THBD\" \"TNFRSF1B\" Practical notes Methodological considerations: NMF, cNMF, and integration End-to-end scripts\u2014from NMF/cNMF execution to downstream sotk2 analyses\u2014are provided under inst/scripts/ , enabling users to reproduce the full workflow and adapt it to their own datasets. Users may generate inputs using either standard NMF (https://github.com/renozao/NMF) or consensus NMF (cNMF; https://github.com/dylkot/cNMF). cNMF was originally developed for single-cell RNA-seq, where expression matrices are typically sparse. In this demonstration, we also apply cNMF to bulk RNA-seq because cNMF operates on the full expression matrix and returns factorization results over all genes. In contrast, standard NMF is often applied to a reduced feature space (for example, highly variable genes) to improve computational efficiency and to focus the factorization on dominant biological signals. When a targeted gene panel is available (for example, molecular subtype signatures such as Verhaak and/or cell-state markers such as Neftel), bulk RNA-seq profiles may be subset accordingly prior to standard NMF, while cNMF can be reserved for sparse modalities such as single-cell or spatial transcriptomics. The resulting NMF and cNMF outputs can then be integrated in sotk2 using correlation-based network construction and community detection. Analytical considerations: NMF/cNMF inputs and integration strategy In this demonstration, ranks 3\u201310, 15, and 20 were evaluated for GLASS and IVYGAP (bulk RNA-seq), whereas spot-resolution Visium v1 data were evaluated at ranks 5\u201330 in increments of 5 (that is, 5, 10, 15, 20, 25, 30). In our experience, inclusion of very high ranks often has limited impact on the dominant community structure identified by sotk2 , because higher-rank components can capture increasingly sample-specific variation, minor biological features, or outlier-driven structure. The optimal rank range is dataset-dependent and is influenced by sample size and heterogeneity. As a practical starting point, we recommend prioritizing lower ranks while avoiding rank 2, which can be disproportionately sensitive to single outliers. Users should assess potential outliers by inspecting metagene usage profiles (and related diagnostic plots) before finalizing the rank grid. Notably, including higher ranks increases the number of metagenes available for network construction; this can be useful when the goal is to interrogate rare programs or outlier-associated structure, but it may also introduce repeated small communities that complicate interpretation. Network construction and integration parameters The correlation threshold used to define edges in the integrated network is a key analytic parameter and should be selected empirically through exploratory evaluation (for example, by examining coefficient distributions and the resulting network sparsity and connectivity). Joint integration of NMF and cNMF outputs is supported; however, the effective shared gene set may be reduced when correlations are computed only over genes present in all inputs. Running NMF on the full expression matrix can lessen this constraint, although the associated computational burden may increase substantially with matrix size and the rank grid under consideration. By default, network construction retains positive correlations exceeding a user-specified cutoff. If anti-correlated structure is scientifically relevant, an alternative thresholding scheme should be defined a priori and explicitly documented (for example, thresholding on absolute correlation while preserving edge sign). The \u201cweighted layout\u201d option is a post hoc visualization procedure that re-weights or rewires edges to encourage co-localization of nodes from the same community and/or cohort, improving graphical interpretability. Importantly, this layout strategy does not alter the underlying correlation estimates or the community assignments.","title":"Signature"},{"location":"signature.html#introduction","text":"This section outlines a practical workflow for extracting metagene-associated genes (MAGs) and prioritizing highly contributing genes for each inferred community. Communities are defined on the metagene correlation network, and community-level gene importance is derived by aggregating information across the metagenes assigned to a given community. Identification of MAGs is essential for biological interpretation, because these genes provide a direct link between latent metagene structure and measurable transcriptional programs. Community-level MAG summaries can be compared against established marker sets and published gene signatures to support functional annotation, assess concordance with known biological states, and reduce the risk of over-interpreting purely network-driven community structure.","title":"Introduction"},{"location":"signature.html#directory-settings","text":"This block defines the working directory used throughout the demo to store downloaded inputs and generated outputs. # If you want to use a user-defined output directory, # uncomment and set the download_dir parameter. # download_dir <- \"/path/to/download\" if (exists(\"download_dir\") && is.character(download_dir) && length(download_dir) == 1 && nzchar(download_dir)) { download_dir <- download_dir } else { download_dir <- tools::R_user_dir(\"sotk2\", \"data\") }","title":"Directory settings"},{"location":"signature.html#load-the-spatial-omics-object","text":"We load the previously generated soObj object, which contains the correlation network and community detection results produced in the earlier steps of the workflow. The script first attaches the sotk2 package and then checks whether soObj.RDS is present in download_dir . We then import the GLASS cohort expression profile ( expr_GLASS.RDS ) downloaded from Zenodo, which is required for downstream extraction of metagene-associated genes (MAGs) and community-level gene summaries. library(sotk2) if (file.exists(file.path(download_dir, \"soObj.RDS\"))) { soObj <- readRDS(file.path(download_dir, \"soObj.RDS\")) } else { stop(\"ERROR: the soObj.RDS file not found.\") } if (file.exists(file.path(download_dir, \"expr_GLASS.RDS\"))) { expr <- readRDS(file.path(download_dir, \"expr_GLASS.RDS\")) } else { stop(\"ERROR: the soObj.RDS file not found.\") }","title":"Load the spatial omics object"},{"location":"signature.html#get-metagene-associated-genes","text":"This section extracts metagene-associated genes (MAGs) by integrating the GLASS expression matrix with the metagene and community structure stored in soObj . The function getMAGs() is then applied to compute, for each metagene, the set of genes most strongly associated with that metagene within the specified cohort. The resulting object ( mags ) is organized hierarchically by cohort, community, and metagene, enabling users to inspect MAGs at multiple resolutions (cohort-wide, community-level, and individual metagene-level). The final lines provide an example of accessing MAGs for a specific metagene within a given community. mags <- getMAGs(soObj, list(GLASS = expr)) message(\"MAGs for the metagenes in Community #1: \", names(mags[[\"GLASS\"]][[1]])[1]) ## MAGs for the metagenes in Community #1: GLASS$05$05 mags[[\"GLASS\"]][[1]][[1]] # [[data/cohort]][[community #]][[metagenes]] ## [1] \"ADORA3\" \"ADPRH\" \"AGTRAP\" \"AIF1\" \"AKR1A1\" \"ALDH3B1\" ## [7] \"ALOX5\" \"ALOX5AP\" \"ANXA2\" \"APOBR\" \"ARHGAP30\" \"ARHGDIB\" ## [13] \"ARPC1B\" \"ARRB2\" \"ASGR2\" \"BATF\" \"BRI3\" \"C1QA\" ## [19] \"C1QB\" \"C1QC\" \"C1R\" \"C1S\" \"C2\" \"C3AR1\" ## [25] \"CALHM2\" \"CAP1\" \"CAPG\" \"CASP1\" \"CASP4\" \"CCR1\" ## [31] \"CCRL2\" \"CD14\" \"CD300A\" \"CD300C\" \"CD300LF\" \"CD33\" ## [37] \"CD37\" \"CD4\" \"CD53\" \"CD68\" \"CD74\" \"CEBPB\" ## [43] \"CEBPD\" \"CERS2\" \"CIB1\" \"CLDN7\" \"CLIC1\" \"CNPY3\" ## [49] \"CSTB\" \"CTSA\" \"CTSB\" \"CTSC\" \"CTSD\" \"CTSL\" ## [55] \"CTSZ\" \"CXCL16\" \"CXCR4\" \"CYBA\" \"DENND1C\" \"DENND2D\" ## [61] \"DNASE2\" \"DOK1\" \"DOK2\" \"DOK3\" \"DUSP1\" \"DUSP23\" ## [67] \"EDEM2\" \"EFEMP2\" \"EMP3\" \"ENG\" \"EVA1B\" \"FAH\" ## [73] \"FBP1\" \"FCER1G\" \"FCGR2B\" \"FCGRT\" \"FERMT3\" \"FLII\" ## [79] \"FTH1\" \"FTL\" \"FUCA2\" \"GAA\" \"GNA15\" \"GPSM3\" ## [85] \"GPX1\" \"GRN\" \"GYPC\" \"HCK\" \"HCST\" \"HEXA\" ## [91] \"HLA.B\" \"HLA.DMA\" \"HLA.DPA1\" \"HLA.DPB1\" \"HLA.DRA\" \"HLA.DRB1\" ## [97] \"HLA.E\" \"HLX\" \"HSD3B7\" \"ICAM1\" \"IER3\" \"IFI30\" ## [103] \"IFNGR2\" \"IL10RB\" \"IL15RA\" \"ISG20\" \"ITGB2\" \"ITPRIP\" ## [109] \"JUN\" \"LAIR1\" \"LAPTM5\" \"LGALS1\" \"LGALS3BP\" \"LILRB3\" ## [115] \"LITAF\" \"LRRC25\" \"MAFB\" \"MGAT1\" \"MS4A4A\" \"MS4A6A\" ## [121] \"MSN\" \"MVP\" \"MXRA8\" \"MYL9\" \"MYO1G\" \"NANS\" ## [127] \"NCF2\" \"NCF4\" \"NFKBIA\" \"NPC2\" \"NUPR1\" \"OSCAR\" ## [133] \"PARVG\" \"PFN1\" \"PILRA\" \"PLAUR\" \"PLIN3\" \"PLTP\" ## [139] \"POLD4\" \"PPM1M\" \"PPP1R18\" \"PTPN6\" \"PYCARD\" \"RAB20\" ## [145] \"RAB42\" \"RAC2\" \"RASAL3\" \"RASSF1\" \"RCN3\" \"RGS19\" ## [151] \"RHOG\" \"RILPL2\" \"RIPK3\" \"RNASE6\" \"RNASET2\" \"RNF130\" ## [157] \"RRAS\" \"S100A11\" \"SASH3\" \"SERF2\" \"SERPINB1\" \"SIGLEC7\" ## [163] \"SIGLEC9\" \"SLAMF8\" \"SLC10A3\" \"SLC11A1\" \"SLC15A3\" \"SLC17A9\" ## [169] \"SLC39A1\" \"SPI1\" \"SRGN\" \"STAB1\" \"STXBP2\" \"SYNGR2\" ## [175] \"TAGLN2\" \"TAX1BP3\" \"TCIRG1\" \"TGFB1\" \"THBD\" \"THEMIS2\" ## [181] \"TLN1\" \"TMED9\" \"TMEM150A\" \"TNFRSF14\" \"TNFRSF1B\" \"TNFSF13\" ## [187] \"TNIP2\" \"TRADD\" \"TRIM21\" \"TSPO\" \"TWF2\" \"TXNDC5\" ## [193] \"TYMP\" \"TYROBP\" \"VAMP5\" \"VAMP8\" \"VAT1\" \"VKORC1\" ## [199] \"VSIG4\" \"WAS\"","title":"Get metagene-associated genes"},{"location":"signature.html#get-highly-contributing-genes","text":"This section prioritizes community-level genes by aggregating metagene-associated gene information across all metagenes assigned to each community. Using the MAGs extracted in the previous step, contributingCommunityGenes() identifies genes that contribute most strongly and consistently to a given community's metagene composition by quantifying how frequently each gene appears among the MAG sets of community member metagenes. By default, the function applies a proportion threshold of > 0.5 , meaning that a gene is retained as a highly contributing community gene only if it is identified as a MAG for more than half of the metagenes within that community. For example, if a community contains 10 metagenes, a gene must be present among the MAGs of at least 6 metagenes to be selected under the default setting. The resulting object is indexed by cohort and community, enabling direct inspection of top-ranked genes for each inferred module. The final lines print an example output showing the highly contributing genes for Community 1 in the GLASS cohort. highlyContributingCommunityGenes <- contributingCommunityGenes(soObj, mags) ## Threhold of the intersection was set to 0.5 message(\"Highly contributing genes in Community #1 from GLASS:\") ## Highly contributing genes in Community #1 from GLASS: highlyContributingCommunityGenes[[\"GLASS\"]][[1]] # Commuinty #1 ## [1] \"ALOX5AP\" \"ANXA2\" \"C1R\" \"C1S\" \"CD14\" \"CD300A\" ## [7] \"CD300C\" \"CEBPB\" \"CLIC1\" \"CSTB\" \"CTSB\" \"CTSC\" ## [13] \"CTSL\" \"CTSZ\" \"DOK2\" \"FBP1\" \"FCER1G\" \"FCGRT\" ## [19] \"GNA15\" \"HCST\" \"IER3\" \"IFI30\" \"LAPTM5\" \"LILRB3\" ## [25] \"MXRA8\" \"MYO1G\" \"NCF4\" \"NFKBIA\" \"OSCAR\" \"PLAUR\" ## [31] \"PLTP\" \"RCN3\" \"RRAS\" \"S100A11\" \"SLAMF8\" \"STAB1\" ## [37] \"TCIRG1\" \"THBD\" \"TNFRSF1B\"","title":"Get highly contributing genes"},{"location":"signature.html#practical-notes","text":"","title":"Practical notes"},{"location":"signature.html#methodological-considerations-nmf-cnmf-and-integration","text":"End-to-end scripts\u2014from NMF/cNMF execution to downstream sotk2 analyses\u2014are provided under inst/scripts/ , enabling users to reproduce the full workflow and adapt it to their own datasets. Users may generate inputs using either standard NMF (https://github.com/renozao/NMF) or consensus NMF (cNMF; https://github.com/dylkot/cNMF). cNMF was originally developed for single-cell RNA-seq, where expression matrices are typically sparse. In this demonstration, we also apply cNMF to bulk RNA-seq because cNMF operates on the full expression matrix and returns factorization results over all genes. In contrast, standard NMF is often applied to a reduced feature space (for example, highly variable genes) to improve computational efficiency and to focus the factorization on dominant biological signals. When a targeted gene panel is available (for example, molecular subtype signatures such as Verhaak and/or cell-state markers such as Neftel), bulk RNA-seq profiles may be subset accordingly prior to standard NMF, while cNMF can be reserved for sparse modalities such as single-cell or spatial transcriptomics. The resulting NMF and cNMF outputs can then be integrated in sotk2 using correlation-based network construction and community detection.","title":"Methodological considerations: NMF, cNMF, and integration"},{"location":"signature.html#analytical-considerations-nmfcnmf-inputs-and-integration-strategy","text":"In this demonstration, ranks 3\u201310, 15, and 20 were evaluated for GLASS and IVYGAP (bulk RNA-seq), whereas spot-resolution Visium v1 data were evaluated at ranks 5\u201330 in increments of 5 (that is, 5, 10, 15, 20, 25, 30). In our experience, inclusion of very high ranks often has limited impact on the dominant community structure identified by sotk2 , because higher-rank components can capture increasingly sample-specific variation, minor biological features, or outlier-driven structure. The optimal rank range is dataset-dependent and is influenced by sample size and heterogeneity. As a practical starting point, we recommend prioritizing lower ranks while avoiding rank 2, which can be disproportionately sensitive to single outliers. Users should assess potential outliers by inspecting metagene usage profiles (and related diagnostic plots) before finalizing the rank grid. Notably, including higher ranks increases the number of metagenes available for network construction; this can be useful when the goal is to interrogate rare programs or outlier-associated structure, but it may also introduce repeated small communities that complicate interpretation.","title":"Analytical considerations: NMF/cNMF inputs and integration strategy"},{"location":"signature.html#network-construction-and-integration-parameters","text":"The correlation threshold used to define edges in the integrated network is a key analytic parameter and should be selected empirically through exploratory evaluation (for example, by examining coefficient distributions and the resulting network sparsity and connectivity). Joint integration of NMF and cNMF outputs is supported; however, the effective shared gene set may be reduced when correlations are computed only over genes present in all inputs. Running NMF on the full expression matrix can lessen this constraint, although the associated computational burden may increase substantially with matrix size and the rank grid under consideration. By default, network construction retains positive correlations exceeding a user-specified cutoff. If anti-correlated structure is scientifically relevant, an alternative thresholding scheme should be defined a priori and explicitly documented (for example, thresholding on absolute correlation while preserving edge sign). The \u201cweighted layout\u201d option is a post hoc visualization procedure that re-weights or rewires edges to encourage co-localization of nodes from the same community and/or cohort, improving graphical interpretability. Importantly, this layout strategy does not alter the underlying correlation estimates or the community assignments.","title":"Network construction and integration parameters"},{"location":"vignettes.html","text":"Introduction This demo script illustrates the use of the sotk2 package through a step-by-step workflow: It demonstrates how to construct a Spatial Omics Set ( soSet ) by integrating (i) NMF-derived outputs as inputs and (ii) an all-pairs correlation matrix as the primary output. The workflow then proceeds to create a spatial omics object ( soObj ), in which a metagene network is inferred by thresholding correlation strengths (for example, Spearman's rho > 0.5). A community detection algorithm is subsequently applied to the resulting network to identify metagene communities, which can be interpreted as candidate biological modules. Following community detection, each community can be systematically annotated using sample-level metadata (for example, molecular subtype labels such as the Verhaak classification) to facilitate biological interpretation. Users may also incorporate external annotations or project-specific features onto the network to support tailored interpretation and downstream analyses. Data download to run the demos Demo data are available from Zenodo ( https://doi.org/10.5281/zenodo.18063318 ). You may download the files directly from the Zenodo record or use the provided helper script to retrieve them programmatically. Two data bundles are provided: core and full The core bundle contains five files comprising cNMF outputs for the GLASS, IVYGAP, and HEILAND datasets, along with the GLASS cohort expression matrix and sample-level annotation metadata. The full bundle includes two additional files; however, UKF269_T_Visium.RDS (which contains Visium v1 slide image) is approximately 542 MB. Because of its size, we recommend downloading the core bundle first to begin running the demos, and downloading UKF269_T_Visium.RDS in the background. This Visium object is required for the visualization steps later in the workflow. # The script below downloads the files to a local directory; # uncomment and set download_dir to your preferred destination. # download_dir <- \"/path/to/download\" .demo_data_manifest <- function(set = c(\"core\", \"full\")) { set <- match.arg(set) manifest_full <- data.frame( file = c( \"annot_GLASS.RDS\", # core, 25 KB \"expr_GLASS.RDS\", # core, 34 MB \"nmfRes_GLASS.RDS\", # core, 13 MB \"nmfRes_HEILAND.RDS\", # core, 57 MB \"nmfRes_IVYGAP.RDS\", # core, 14 MB \"UKF269_T_spots.RDS\", # full, 20 KB \"UKF269_T_Visium.RDS\". # full, 542 MB (Visium v1 slide image) ), url = c( \"https://zenodo.org/records/18063318/files/annot_GLASS.RDS\", \"https://zenodo.org/records/18063318/files/expr_GLASS.RDS\", \"https://zenodo.org/records/18063318/files/nmfRes_GLASS.RDS\", \"https://zenodo.org/records/18063318/files/nmfRes_HEILAND.RDS\", \"https://zenodo.org/records/18063318/files/nmfRes_IVYGAP.RDS\", \"https://zenodo.org/records/18063318/files/UKF269_T_spots.RDS\", \"https://zenodo.org/records/18063318/files/UKF269_T_Visium.RDS\" ), md5 = c( \"484c9d3637912c683a685182d6303d15\", \"f270145499efdc1da08aac39ae4f4c78\", \"269dc92869c8efad5ae539fe10cee9cb\", \"016612979539a409fdf74c0692d97ffa\", \"a12613ef9a08fc3328169ed7cbe83229\", \"d2312d01b19695f5ec58bdeef231ea24\", \"fad3a540e1280bbd9ee68fffc8df78d6\" ), stringsAsFactors = FALSE ) if (set == \"full\") { manifest <- manifest_full } else { manifest <- manifest_full[!grepl(\"^UKF269_T_\", manifest_full$file), , drop = FALSE] } return(manifest) } .verify_md5 <- function(path, expected_md5) { if (is.na(expected_md5) || expected_md5 == \"\") { return(TRUE) } actual <- tools::md5sum(path) isTRUE(unname(actual) == expected_md5) } download_demo_data <- function( set = c(\"core\", \"full\"), download_dir = tools::R_user_dir(\"sotk2\", \"data\"), overwrite = FALSE) { set <- match.arg(set) if (!dir.exists(download_dir)) { dir.create(download_dir, recursive = TRUE) } manifest <- .demo_data_manifest(set = set) paths <- file.path(download_dir, manifest$file) message(\"Checking demo data files... (set = \", set, \")\") for (i in seq_len(nrow(manifest))) { needs_download <- overwrite || !file.exists(paths[i]) if (!needs_download) { if (!.verify_md5(paths[i], manifest$md5[i])) { message(sprintf( \"Checksum mismatch for %s; re-downloading.\", manifest$file[i] )) needs_download <- TRUE } } if (needs_download) { message(sprintf(\"Downloading %s\", manifest$file[i])) download.file( url = manifest$url[i], destfile = paths[i], mode = \"wb\", quiet = TRUE ) if (!.verify_md5(paths[i], manifest$md5[i])) { stop(sprintf( \"Checksum verification failed for %s\", manifest$file[i] )) } } } stats::setNames(paths, manifest$file) } options(timeout = max(1200, getOption(\"timeout\"))) # 20 minutes if (exists(\"download_dir\") && is.character(download_dir) && length(download_dir) == 1 && nzchar(download_dir)) { paths <- download_demo_data(set = \"core\", download_dir = download_dir) } else { paths <- download_demo_data(set = \"core\") } ## Checking demo data files... (set = core) Directory settings This block defines the working directory used throughout the demo to store downloaded inputs and generated outputs. If a valid download_dir variable already exists in the current R session, the script reuses that user-specified location. Otherwise, it defaults to a standard, package-specific data directory returned by tools::R_user_dir(\"sotk2\", \"data\") , which provides a consistent and user-writable storage path across platforms. if (exists(\"download_dir\") && is.character(download_dir) && length(download_dir) == 1 && nzchar(download_dir)) { download_dir <- download_dir } else { download_dir <- tools::R_user_dir(\"sotk2\", \"data\") } Load the sotk2 library If sotk2 is not yet installed, please refer to the project repository for installation instructions: https://github.com/Snyder-Institute/sotk2 . After loading sotk2 , its required dependencies (including igraph , methods , NMF , RColorBrewer , and stringr ) are loaded to support the full demonstration workflow. # install.packages(\"devtools\") # devtools::install_github(\"Snyder-Institute/sotk2\") library(sotk2) Load cNMF objects In this section, we load the precomputed cNMF result objects for three cohorts (GLASS, IVYGAP, and HEILAND) from the downloaded demo files. These cohort-specific objects are then assembled into a single named list ( dataL ), which serves as the primary input for subsequent sotk2 workflows. We additionally define: The candidate factorization ranks to consider for each cohort ( rankL ) A cohort-specific color palette ( dataCol ) to ensure consistent visualization across figures The correlation method ( corMethod ) used to quantify metagene similarity during the downstream integration and network-construction steps glass <- readRDS(file.path(download_dir, \"nmfRes_GLASS.RDS\")) ivygap <- readRDS(file.path(download_dir, \"nmfRes_IVYGAP.RDS\")) heiland <- readRDS(file.path(download_dir, \"nmfRes_HEILAND.RDS\")) dataL <- list( GLASS = glass, IVYGAP = ivygap, HEILAND = heiland ) rankL <- list( GLASS = c(3:10, 15, 20), IVYGAP = c(3:10, 15, 20), HEILAND = seq(5, 30, 5) ) dataCol <- c( \"GLASS\" = \"cyan3\", \"IVYGAP\" = \"chartreuse1\", \"HEILAND\" = \"magenta\" ) corMethod <- \"spearman\" Calculate pairwise correlations In this section, we construct a Spatial Omics Set ( soSet ) by integrating the cohort-specific cNMF objects and the corresponding rank specifications. Internally, SOSet() concatenates the metagene loading matrices (the W matrices) across cohorts and selected ranks, thereby placing all metagenes into a common representation suitable for cross-dataset comparison. It then computes an all-pairs correlation matrix across the concatenated metagenes using the specified correlation metric ( corMet ; here, Spearman). The resulting soSet object stores the inputs, cohort metadata (including visualization colors), and the computed correlation structure, which serves as the basis for downstream network inference and community detection. soSet <- SOSet( NMFobjL = dataL, NMFrankL = rankL, dataCol = dataCol, corMet = corMethod ) ## 3 dataset(s) found in the list: GLASS, IVYGAP, HEILAND ## Loading: GLASS [Rank: 3, 4, 5, 6, 7, 8, 9, 10, 15, 20] ## Loading: IVYGAP [Rank: 3, 4, 5, 6, 7, 8, 9, 10, 15, 20] ## Loading: HEILAND [Rank: 5, 10, 15, 20, 25, 30] ## WARNING::Number of genes are different across datasets. ## Calculating: all pairwise correlation coefficients. ## Correlation computed with ## \u2022 Method: 'spearman' ## \u2022 Missing treated using: 'pairwise.complete.obs' ## ## Assigned color(s): ## > GLASS: cyan3 ## > IVYGAP: chartreuse1 ## > HEILAND: magenta soSet ## Dataset(s): ## GLASS (cyan3) ## IVYGAP (chartreuse1) ## HEILAND (magenta) ## Select rank(s): ## GLASS: 3, 4, 5, 6, 7, 8, 9, 10, 15, 20 ## IVYGAP: 3, 4, 5, 6, 7, 8, 9, 10, 15, 20 ## HEILAND: 5, 10, 15, 20, 25, 30 ## Basis (W) matrices: ## #Genes : 26316 ## #Metagenes : 279 ## Correlation method: ## spearman (pairwise.complete.obs) ## Correlation matrix: ## Symmetric matrix with 279 columns X 279 rows. Generate a correlation network This section converts the correlation structure stored in soSet into a metagene similarity network and performs community detection under user-defined settings. First, a correlation threshold ( coefThre ) is applied to retain only sufficiently strong metagene-metagene associations (here, correlations \u2265 0.3), yielding a sparse graph representation. Community detection is then run with a fixed random seed ( seed ) to ensure reproducibility and a specified number of iterations ( niter ) to stabilize the optimization. The parameters commWeight and cohortWeight are not used during the community detection step. Instead, they are applied after communities have been identified to rewire or reweight edges for visualization, thereby influencing the spatial arrangement of nodes in network layouts. Specifically, cohortWeight increases the tendency for metagenes from the same cohort (dataset) to cluster together, which is useful when cohort-specific structure is a primary interpretive focus. In contrast, commWeight increases the tendency for metagenes assigned to the same community to cluster, which is preferable when emphasizing community-level modular organization. By tuning these weights, users can generate complementary visual representations of the same inferred communities without altering the underlying community assignments. The resulting soObj stores the inferred network and the identified communities for downstream annotation and visualization. corrCoefThre <- 0.3 seed <- 1234 niter <- 1000 commWeight <- 100 cohortWeight <- 10 soObj <- SOTK( SOSet = soSet, coefThre = corrCoefThre, seed = seed, niter = niter, commWeight = commWeight, cohortWeight = cohortWeight ) ## Seed: 1234 ## Community search algorithm: ## Fast Greedy ## Updating weights for ## Community #1 ## Community #2 ## Community #3 ## Community #4 ## Community #5 ## Community #6 ## Community #7 ## Community #8 ## Updating weights for ## Data: GLASS ## Data: IVYGAP ## Data: HEILAND ## Calculating new layout based on new weights. ## Community-level network generated. soObj ## Correlation network: ## Nodes : 279 ## Communities : 8 identified ## Parameters: ## coefThre : 0.3 ## seed : 1234 ## niter : 1000 ## drop : FALSE ## searchMet : greedy ## commWeight : 100 ## cohortWeight: 10 Save the object for reuse To avoid repeating computationally intensive steps in later parts of the demo, we serialize the resulting soObj object to disk as an .RDS file. This saved object can be reloaded in downstream sections to reproduce the same network and community assignments without rerunning the correlation-network construction and community detection. saveRDS(soObj, file.path(download_dir, \"soObj.RDS\")) message(\"soObj.RDS was created.\") ## soObj.RDS was created.","title":"Vignettes"},{"location":"vignettes.html#introduction","text":"This demo script illustrates the use of the sotk2 package through a step-by-step workflow: It demonstrates how to construct a Spatial Omics Set ( soSet ) by integrating (i) NMF-derived outputs as inputs and (ii) an all-pairs correlation matrix as the primary output. The workflow then proceeds to create a spatial omics object ( soObj ), in which a metagene network is inferred by thresholding correlation strengths (for example, Spearman's rho > 0.5). A community detection algorithm is subsequently applied to the resulting network to identify metagene communities, which can be interpreted as candidate biological modules. Following community detection, each community can be systematically annotated using sample-level metadata (for example, molecular subtype labels such as the Verhaak classification) to facilitate biological interpretation. Users may also incorporate external annotations or project-specific features onto the network to support tailored interpretation and downstream analyses.","title":"Introduction"},{"location":"vignettes.html#data-download-to-run-the-demos","text":"Demo data are available from Zenodo ( https://doi.org/10.5281/zenodo.18063318 ). You may download the files directly from the Zenodo record or use the provided helper script to retrieve them programmatically. Two data bundles are provided: core and full The core bundle contains five files comprising cNMF outputs for the GLASS, IVYGAP, and HEILAND datasets, along with the GLASS cohort expression matrix and sample-level annotation metadata. The full bundle includes two additional files; however, UKF269_T_Visium.RDS (which contains Visium v1 slide image) is approximately 542 MB. Because of its size, we recommend downloading the core bundle first to begin running the demos, and downloading UKF269_T_Visium.RDS in the background. This Visium object is required for the visualization steps later in the workflow. # The script below downloads the files to a local directory; # uncomment and set download_dir to your preferred destination. # download_dir <- \"/path/to/download\" .demo_data_manifest <- function(set = c(\"core\", \"full\")) { set <- match.arg(set) manifest_full <- data.frame( file = c( \"annot_GLASS.RDS\", # core, 25 KB \"expr_GLASS.RDS\", # core, 34 MB \"nmfRes_GLASS.RDS\", # core, 13 MB \"nmfRes_HEILAND.RDS\", # core, 57 MB \"nmfRes_IVYGAP.RDS\", # core, 14 MB \"UKF269_T_spots.RDS\", # full, 20 KB \"UKF269_T_Visium.RDS\". # full, 542 MB (Visium v1 slide image) ), url = c( \"https://zenodo.org/records/18063318/files/annot_GLASS.RDS\", \"https://zenodo.org/records/18063318/files/expr_GLASS.RDS\", \"https://zenodo.org/records/18063318/files/nmfRes_GLASS.RDS\", \"https://zenodo.org/records/18063318/files/nmfRes_HEILAND.RDS\", \"https://zenodo.org/records/18063318/files/nmfRes_IVYGAP.RDS\", \"https://zenodo.org/records/18063318/files/UKF269_T_spots.RDS\", \"https://zenodo.org/records/18063318/files/UKF269_T_Visium.RDS\" ), md5 = c( \"484c9d3637912c683a685182d6303d15\", \"f270145499efdc1da08aac39ae4f4c78\", \"269dc92869c8efad5ae539fe10cee9cb\", \"016612979539a409fdf74c0692d97ffa\", \"a12613ef9a08fc3328169ed7cbe83229\", \"d2312d01b19695f5ec58bdeef231ea24\", \"fad3a540e1280bbd9ee68fffc8df78d6\" ), stringsAsFactors = FALSE ) if (set == \"full\") { manifest <- manifest_full } else { manifest <- manifest_full[!grepl(\"^UKF269_T_\", manifest_full$file), , drop = FALSE] } return(manifest) } .verify_md5 <- function(path, expected_md5) { if (is.na(expected_md5) || expected_md5 == \"\") { return(TRUE) } actual <- tools::md5sum(path) isTRUE(unname(actual) == expected_md5) } download_demo_data <- function( set = c(\"core\", \"full\"), download_dir = tools::R_user_dir(\"sotk2\", \"data\"), overwrite = FALSE) { set <- match.arg(set) if (!dir.exists(download_dir)) { dir.create(download_dir, recursive = TRUE) } manifest <- .demo_data_manifest(set = set) paths <- file.path(download_dir, manifest$file) message(\"Checking demo data files... (set = \", set, \")\") for (i in seq_len(nrow(manifest))) { needs_download <- overwrite || !file.exists(paths[i]) if (!needs_download) { if (!.verify_md5(paths[i], manifest$md5[i])) { message(sprintf( \"Checksum mismatch for %s; re-downloading.\", manifest$file[i] )) needs_download <- TRUE } } if (needs_download) { message(sprintf(\"Downloading %s\", manifest$file[i])) download.file( url = manifest$url[i], destfile = paths[i], mode = \"wb\", quiet = TRUE ) if (!.verify_md5(paths[i], manifest$md5[i])) { stop(sprintf( \"Checksum verification failed for %s\", manifest$file[i] )) } } } stats::setNames(paths, manifest$file) } options(timeout = max(1200, getOption(\"timeout\"))) # 20 minutes if (exists(\"download_dir\") && is.character(download_dir) && length(download_dir) == 1 && nzchar(download_dir)) { paths <- download_demo_data(set = \"core\", download_dir = download_dir) } else { paths <- download_demo_data(set = \"core\") } ## Checking demo data files... (set = core)","title":"Data download to run the demos"},{"location":"vignettes.html#directory-settings","text":"This block defines the working directory used throughout the demo to store downloaded inputs and generated outputs. If a valid download_dir variable already exists in the current R session, the script reuses that user-specified location. Otherwise, it defaults to a standard, package-specific data directory returned by tools::R_user_dir(\"sotk2\", \"data\") , which provides a consistent and user-writable storage path across platforms. if (exists(\"download_dir\") && is.character(download_dir) && length(download_dir) == 1 && nzchar(download_dir)) { download_dir <- download_dir } else { download_dir <- tools::R_user_dir(\"sotk2\", \"data\") }","title":"Directory settings"},{"location":"vignettes.html#load-the-sotk2-library","text":"If sotk2 is not yet installed, please refer to the project repository for installation instructions: https://github.com/Snyder-Institute/sotk2 . After loading sotk2 , its required dependencies (including igraph , methods , NMF , RColorBrewer , and stringr ) are loaded to support the full demonstration workflow. # install.packages(\"devtools\") # devtools::install_github(\"Snyder-Institute/sotk2\") library(sotk2)","title":"Load the sotk2 library"},{"location":"vignettes.html#load-cnmf-objects","text":"In this section, we load the precomputed cNMF result objects for three cohorts (GLASS, IVYGAP, and HEILAND) from the downloaded demo files. These cohort-specific objects are then assembled into a single named list ( dataL ), which serves as the primary input for subsequent sotk2 workflows. We additionally define: The candidate factorization ranks to consider for each cohort ( rankL ) A cohort-specific color palette ( dataCol ) to ensure consistent visualization across figures The correlation method ( corMethod ) used to quantify metagene similarity during the downstream integration and network-construction steps glass <- readRDS(file.path(download_dir, \"nmfRes_GLASS.RDS\")) ivygap <- readRDS(file.path(download_dir, \"nmfRes_IVYGAP.RDS\")) heiland <- readRDS(file.path(download_dir, \"nmfRes_HEILAND.RDS\")) dataL <- list( GLASS = glass, IVYGAP = ivygap, HEILAND = heiland ) rankL <- list( GLASS = c(3:10, 15, 20), IVYGAP = c(3:10, 15, 20), HEILAND = seq(5, 30, 5) ) dataCol <- c( \"GLASS\" = \"cyan3\", \"IVYGAP\" = \"chartreuse1\", \"HEILAND\" = \"magenta\" ) corMethod <- \"spearman\"","title":"Load cNMF objects"},{"location":"vignettes.html#calculate-pairwise-correlations","text":"In this section, we construct a Spatial Omics Set ( soSet ) by integrating the cohort-specific cNMF objects and the corresponding rank specifications. Internally, SOSet() concatenates the metagene loading matrices (the W matrices) across cohorts and selected ranks, thereby placing all metagenes into a common representation suitable for cross-dataset comparison. It then computes an all-pairs correlation matrix across the concatenated metagenes using the specified correlation metric ( corMet ; here, Spearman). The resulting soSet object stores the inputs, cohort metadata (including visualization colors), and the computed correlation structure, which serves as the basis for downstream network inference and community detection. soSet <- SOSet( NMFobjL = dataL, NMFrankL = rankL, dataCol = dataCol, corMet = corMethod ) ## 3 dataset(s) found in the list: GLASS, IVYGAP, HEILAND ## Loading: GLASS [Rank: 3, 4, 5, 6, 7, 8, 9, 10, 15, 20] ## Loading: IVYGAP [Rank: 3, 4, 5, 6, 7, 8, 9, 10, 15, 20] ## Loading: HEILAND [Rank: 5, 10, 15, 20, 25, 30] ## WARNING::Number of genes are different across datasets. ## Calculating: all pairwise correlation coefficients. ## Correlation computed with ## \u2022 Method: 'spearman' ## \u2022 Missing treated using: 'pairwise.complete.obs' ## ## Assigned color(s): ## > GLASS: cyan3 ## > IVYGAP: chartreuse1 ## > HEILAND: magenta soSet ## Dataset(s): ## GLASS (cyan3) ## IVYGAP (chartreuse1) ## HEILAND (magenta) ## Select rank(s): ## GLASS: 3, 4, 5, 6, 7, 8, 9, 10, 15, 20 ## IVYGAP: 3, 4, 5, 6, 7, 8, 9, 10, 15, 20 ## HEILAND: 5, 10, 15, 20, 25, 30 ## Basis (W) matrices: ## #Genes : 26316 ## #Metagenes : 279 ## Correlation method: ## spearman (pairwise.complete.obs) ## Correlation matrix: ## Symmetric matrix with 279 columns X 279 rows.","title":"Calculate pairwise correlations"},{"location":"vignettes.html#generate-a-correlation-network","text":"This section converts the correlation structure stored in soSet into a metagene similarity network and performs community detection under user-defined settings. First, a correlation threshold ( coefThre ) is applied to retain only sufficiently strong metagene-metagene associations (here, correlations \u2265 0.3), yielding a sparse graph representation. Community detection is then run with a fixed random seed ( seed ) to ensure reproducibility and a specified number of iterations ( niter ) to stabilize the optimization. The parameters commWeight and cohortWeight are not used during the community detection step. Instead, they are applied after communities have been identified to rewire or reweight edges for visualization, thereby influencing the spatial arrangement of nodes in network layouts. Specifically, cohortWeight increases the tendency for metagenes from the same cohort (dataset) to cluster together, which is useful when cohort-specific structure is a primary interpretive focus. In contrast, commWeight increases the tendency for metagenes assigned to the same community to cluster, which is preferable when emphasizing community-level modular organization. By tuning these weights, users can generate complementary visual representations of the same inferred communities without altering the underlying community assignments. The resulting soObj stores the inferred network and the identified communities for downstream annotation and visualization. corrCoefThre <- 0.3 seed <- 1234 niter <- 1000 commWeight <- 100 cohortWeight <- 10 soObj <- SOTK( SOSet = soSet, coefThre = corrCoefThre, seed = seed, niter = niter, commWeight = commWeight, cohortWeight = cohortWeight ) ## Seed: 1234 ## Community search algorithm: ## Fast Greedy ## Updating weights for ## Community #1 ## Community #2 ## Community #3 ## Community #4 ## Community #5 ## Community #6 ## Community #7 ## Community #8 ## Updating weights for ## Data: GLASS ## Data: IVYGAP ## Data: HEILAND ## Calculating new layout based on new weights. ## Community-level network generated. soObj ## Correlation network: ## Nodes : 279 ## Communities : 8 identified ## Parameters: ## coefThre : 0.3 ## seed : 1234 ## niter : 1000 ## drop : FALSE ## searchMet : greedy ## commWeight : 100 ## cohortWeight: 10","title":"Generate a correlation network"},{"location":"vignettes.html#save-the-object-for-reuse","text":"To avoid repeating computationally intensive steps in later parts of the demo, we serialize the resulting soObj object to disk as an .RDS file. This saved object can be reloaded in downstream sections to reproduce the same network and community assignments without rerunning the correlation-network construction and community detection. saveRDS(soObj, file.path(download_dir, \"soObj.RDS\")) message(\"soObj.RDS was created.\") ## soObj.RDS was created.","title":"Save the object for reuse"},{"location":"visualizations.html","text":"Introduction This demo script demonstrates how to visualize the Spatial Omics Set ( soSet ) to facilitate interpretation of the derived metagene structure and cross-cohort relationships. Each figure generated below is accompanied by a detailed explanation describing its rationale, key features, and guidance for interpretation. Directory settings This block defines the working directory used throughout the demo to store downloaded inputs and generated outputs. # If you want to use a user-defined output directory, # uncomment and set the download_dir parameter. # download_dir <- \"/path/to/download\" # where soObj.RDS is located if (exists(\"download_dir\") && is.character(download_dir) && length(download_dir) == 1 && nzchar(download_dir)) { download_dir <- download_dir } else { download_dir <- tools::R_user_dir(\"sotk2\", \"data\") } Load the spatial omics object We load the previously generated soObj object, which contains the correlation network and community detection results produced in the earlier steps of the workflow. The script first attaches the sotk2 package and then checks whether soObj.RDS is present in download_dir . library(sotk2) if (file.exists(file.path(download_dir, \"soObj.RDS\"))) { soObj <- readRDS(file.path(download_dir, \"soObj.RDS\")) } else { stop(\"ERROR: the soObj.RDS file not found.\") } Correlation coefficient density This panel summarizes the distribution of pairwise correlation coefficients within and between datasets using a matrix-style layout. For three datasets, the figure comprises six histograms corresponding to all dataset pairs. The diagonal panels display within-dataset correlation distributions. The lower-left panels show between-dataset correlation distributions for each dataset pair, whereas the upper-right panels provide the corresponding overall coefficient distributions as a reference for comparison. The filename argument controls output: setting filename = NULL prints to the active graphics device, whereas providing a path writes the figure to disk. plotCorrDensity(soObj@SOSet, filename = NULL) Visualization parameters This section defines core visualization parameters that control the appearance and readability of the network plots. Specifically, nodeSize and nodeLabelSize determine the size of nodes and the corresponding label text, respectively, while edgeAlpha sets the transparency of edges to reduce visual clutter in dense networks and to emphasize higher-level structure. nodeSize <- 10 nodeLabelSize <- 2 edgeAlpha <- 0.8 Correlation-network plots In this section, we generate network visualizations derived from the correlation graph stored in soObj . The plotting function supports flexible display options, allowing users to Toggle vertex labels ( label = TRUE/FALSE ) Color or annotate nodes by cohort membership ( annot = \"cohort\" ) or by inferred community assignment ( annot = \"community\" ) Render either an unweighted network ( weighted = FALSE ) or a weighted network ( weighted = TRUE , where edge widths reflect correlation strength) plotNetwork(soObj, label = FALSE, annot = \"cohort\", weighted = FALSE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = TRUE, annot = \"cohort\", weighted = FALSE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = FALSE, annot = \"community\", weighted = FALSE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = TRUE, annot = \"community\", weighted = FALSE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = FALSE, annot = \"community\", weighted = TRUE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = TRUE, annot = \"community\", weighted = TRUE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = FALSE, annot = \"cohort\", weighted = TRUE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = TRUE, annot = \"cohort\", weighted = TRUE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) Community network properties The following plot summarizes community composition by reporting the number of metagenes assigned to each detected community, stratified by dataset. This visualization provides a compact overview of how communities are supported across cohorts and highlights communities that are cohort-specific versus broadly shared. Metagenes derived from higher-rank factorizations often capture increasingly sample-specific patterns rather than broadly conserved biological programs. Consequently, communities dominated by high-rank metagenes may reflect cohort- or sample-idiosyncratic structure and may be less likely to represent generalizable biological signals that are reproducibly observed across datasets. statComm(soObj, filename = NULL) Community-level network layout This step generates a community-level network in which each node represents a detected community. Node size reflects the number of metagenes (GEPs) assigned to the community, and edge thickness summarizes the extent of connectivity between communities (that is, the number of inter-community edges in the underlying metagene network). In subsequent sections, this community-level layout will be augmented with sample-level annotations to support biological interpretation of the inferred modules. plotCommNetwork(soObj, vertexInfo = NULL, filename = NULL)","title":"Visualizations"},{"location":"visualizations.html#introduction","text":"This demo script demonstrates how to visualize the Spatial Omics Set ( soSet ) to facilitate interpretation of the derived metagene structure and cross-cohort relationships. Each figure generated below is accompanied by a detailed explanation describing its rationale, key features, and guidance for interpretation.","title":"Introduction"},{"location":"visualizations.html#directory-settings","text":"This block defines the working directory used throughout the demo to store downloaded inputs and generated outputs. # If you want to use a user-defined output directory, # uncomment and set the download_dir parameter. # download_dir <- \"/path/to/download\" # where soObj.RDS is located if (exists(\"download_dir\") && is.character(download_dir) && length(download_dir) == 1 && nzchar(download_dir)) { download_dir <- download_dir } else { download_dir <- tools::R_user_dir(\"sotk2\", \"data\") }","title":"Directory settings"},{"location":"visualizations.html#load-the-spatial-omics-object","text":"We load the previously generated soObj object, which contains the correlation network and community detection results produced in the earlier steps of the workflow. The script first attaches the sotk2 package and then checks whether soObj.RDS is present in download_dir . library(sotk2) if (file.exists(file.path(download_dir, \"soObj.RDS\"))) { soObj <- readRDS(file.path(download_dir, \"soObj.RDS\")) } else { stop(\"ERROR: the soObj.RDS file not found.\") }","title":"Load the spatial omics object"},{"location":"visualizations.html#correlation-coefficient-density","text":"This panel summarizes the distribution of pairwise correlation coefficients within and between datasets using a matrix-style layout. For three datasets, the figure comprises six histograms corresponding to all dataset pairs. The diagonal panels display within-dataset correlation distributions. The lower-left panels show between-dataset correlation distributions for each dataset pair, whereas the upper-right panels provide the corresponding overall coefficient distributions as a reference for comparison. The filename argument controls output: setting filename = NULL prints to the active graphics device, whereas providing a path writes the figure to disk. plotCorrDensity(soObj@SOSet, filename = NULL)","title":"Correlation coefficient density"},{"location":"visualizations.html#visualization-parameters","text":"This section defines core visualization parameters that control the appearance and readability of the network plots. Specifically, nodeSize and nodeLabelSize determine the size of nodes and the corresponding label text, respectively, while edgeAlpha sets the transparency of edges to reduce visual clutter in dense networks and to emphasize higher-level structure. nodeSize <- 10 nodeLabelSize <- 2 edgeAlpha <- 0.8","title":"Visualization parameters"},{"location":"visualizations.html#correlation-network-plots","text":"In this section, we generate network visualizations derived from the correlation graph stored in soObj . The plotting function supports flexible display options, allowing users to Toggle vertex labels ( label = TRUE/FALSE ) Color or annotate nodes by cohort membership ( annot = \"cohort\" ) or by inferred community assignment ( annot = \"community\" ) Render either an unweighted network ( weighted = FALSE ) or a weighted network ( weighted = TRUE , where edge widths reflect correlation strength) plotNetwork(soObj, label = FALSE, annot = \"cohort\", weighted = FALSE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = TRUE, annot = \"cohort\", weighted = FALSE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = FALSE, annot = \"community\", weighted = FALSE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = TRUE, annot = \"community\", weighted = FALSE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = FALSE, annot = \"community\", weighted = TRUE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = TRUE, annot = \"community\", weighted = TRUE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = FALSE, annot = \"cohort\", weighted = TRUE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize) plotNetwork(soObj, label = TRUE, annot = \"cohort\", weighted = TRUE, edgeAlpha = edgeAlpha, filename = NULL, vertexSize = nodeSize, vertexLabelCex = nodeLabelSize)","title":"Correlation-network plots"},{"location":"visualizations.html#community-network-properties","text":"The following plot summarizes community composition by reporting the number of metagenes assigned to each detected community, stratified by dataset. This visualization provides a compact overview of how communities are supported across cohorts and highlights communities that are cohort-specific versus broadly shared. Metagenes derived from higher-rank factorizations often capture increasingly sample-specific patterns rather than broadly conserved biological programs. Consequently, communities dominated by high-rank metagenes may reflect cohort- or sample-idiosyncratic structure and may be less likely to represent generalizable biological signals that are reproducibly observed across datasets. statComm(soObj, filename = NULL)","title":"Community network properties"},{"location":"visualizations.html#community-level-network-layout","text":"This step generates a community-level network in which each node represents a detected community. Node size reflects the number of metagenes (GEPs) assigned to the community, and edge thickness summarizes the extent of connectivity between communities (that is, the number of inter-community edges in the underlying metagene network). In subsequent sections, this community-level layout will be augmented with sample-level annotations to support biological interpretation of the inferred modules. plotCommNetwork(soObj, vertexInfo = NULL, filename = NULL)","title":"Community-level network layout"}]}